<!DOCTYPE html>
<html lang="en" class="staticrypt-html">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/images/waving.png" />
    <title>Locked! | Sunny's Website</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #FFC000;
        }

        .staticrypt-page {
            max-width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            /*background: #000000;*/
            border: 2px solid #FFC000;
            color: #FFFFFF;
            width: 60%;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        @media (min-width: 768px) {
            .staticrypt-form {
                width: 80%;
                margin: 0 auto 100px;
                padding: 45px;
                font-size: large;
            }
        }

        .staticrypt-form input[type="password"],
        input[type="text"] {
            background: inherit;
            border: 0;
            box-sizing: border-box; /* This ensures padding is included in the total width */
            font-size: 14px;
            outline: 0;
            padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
            width: 100%;
        }

        .staticrypt-password-container {
            position: relative;
            outline: 0;
            background: /*#f2f2f2*/white;
            width: 100%;
            border: 2px solid #FFC000;
            margin: 0 0 15px;
            box-sizing: border-box;
            color: black;
        }

        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            height: 20px;
            opacity: 60%;
            padding-right: 5px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            /*background: #000000;*/
            width: 100%;
            border: #FFC000 solid 1px;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #FFC000;
            filter: brightness(92%);
        }

        .staticrypt-decrypt-button {
            transition: 0.3s ease-in-out;
        }

        .staticrypt-decrypt-button:hover {
            color: black;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
            /*background-color: black;*/
        }

        .staticrypt-content {
            height: calc(100% - 101px);
            margin-bottom: 0;
            /*background: !*#76B852*!#000000;*/
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        @media (min-width: 768px) {
            .staticrypt-content {
                height: calc(100% - 70px);
            }
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: small;
            margin-top: 10px;
            margin-bottom: -10px;
        }

        @media (min-width: 768px) {
            .staticrypt-title {
                font-size: larger;
                margin-top: 10px;
                margin-bottom: -10px;
            }
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .staticrypt-hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: calc(100% - 101px);
            display: flex;
            align-items: center;
            justify-content: center;
            /*background-color: black;*/
        }

        @media (min-width: 768px) {
            .staticrypt-spinner-container {
                height: calc(100% - 70px);
            }
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid #FFC000/*gray*/;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
    <!-- My own things -->
    <link href="/output.css" rel="stylesheet"/>
</head>

<body class="staticrypt-body bg-n-8">
<div>
    <div class="top-0 left-0 w-full border-b border-colour-7 lg:backdrop-blur-sm h-[101px] lg:h-[70px]">
        <div class="flex items-center px-5 lg:px-7.5 xl:px-10 max-lg:py-4">
            <a class="lg:block w-[60px] xl:ml-2" href="/index.html"><img src="/images/sunnylurking.png" alt="leftlurk"></a>
            <nav class="relative left-0 right-0 bottom-0 ml-auto lg:mx-auto">
                <div class="hidden lg:inline-flex relative flex-col items-center justify-center space-x-20 m-auto lg:flex-row">
                    <a href="/index.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Home</a>
                    <a href="/pages/aboutme.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">About Me</a>
                    <a href="/pages/projects.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Projects</a>
                    <a href="/pages/contacts.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Contacts</a>
                    <a href="/pages/blogs/menu.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Blog</a>
                    <a href="/pages/miscellaneous.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Misc.</a>
                </div>
                <div class="flex lg:hidden text-center">
                    <div class="absolute right-10 hidden w-60 border-colour-7 border-2 rounded-lg overflow-auto" id="navbarHamburger" style="z-index: 10">
                        <ul class="flex flex-col font-medium">
                            <li>
                                <a href="/index.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Home</a>
                            </li>
                            <li>
                                <a href="/pages/aboutme.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">About Me</a>
                            </li>
                            <li>
                                <a href="/pages/projects.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Projects</a>
                            </li>
                            <li>
                                <a href="/pages/contacts.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Contacts</a>
                            </li>
                            <li>
                                <a href="/pages/blogs/menu.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Blog</a>
                            </li>
                            <li>
                                <a href="/pages/miscellaneous.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Misc.</a>
                            </li>
                        </ul>
                    </div>
                    <button id="burg" class="button inline-flex items-center justify-center p-2 w-10 h-10 text-sm text-gray-500 rounded-lg focus:outline-none border-2 border-colour-7">
                        <span class="sr-only">Open main menu</span>
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 17 14">
                            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 1h15M1 7h15M1 13h15"/>
                        </svg>
                    </button>
                </div>
            </nav>
            <a class="hidden lg:block w-[60px] xl:mr-2" href="/index.html"><img src="/images/sunnylurkinginverted.png" alt="rightlurk"></a>
        </div>
    </div>
</div>

<script>
    const burgButtonTemplate = document.getElementById("burg");
    const burgMenuTemplate = document.getElementById("navbarHamburger")

    burgButtonTemplate.addEventListener("click", () => {
        burgMenuTemplate.classList.toggle("hidden");
    })
</script>
<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Locked!</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr" />

            <form id="staticrypt-form" action="#" method="post">
                <div class="staticrypt-password-container">
                    <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                    />

                    <img
                            class="staticrypt-toggle-password-visibility"
                            alt="Show password"
                            title="Show password"
                            src="../images/invisible.svg"
                    />
                    <!--                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="-->
                </div>

                <label id="staticrypt-remember-label" class="staticrypt-remember staticrypt-hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />
            </form>
        </div>
    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
        const exports = {};
        const cryptoEngine = ((function(){
            const exports = {};
            const { subtle } = crypto;

            const IV_BITS = 16 * 8;
            const HEX_BITS = 4;
            const ENCRYPTION_ALGO = "AES-CBC";

            /**
             * Translates between utf8 encoded hexadecimal strings
             * and Uint8Array bytes.
             */
            const HexEncoder = {
                /**
                 * hex string -> bytes
                 * @param {string} hexString
                 * @returns {Uint8Array}
                 */
                parse: function (hexString) {
                    if (hexString.length % 2 !== 0) throw "Invalid hexString";
                    const arrayBuffer = new Uint8Array(hexString.length / 2);

                    for (let i = 0; i < hexString.length; i += 2) {
                        const byteValue = parseInt(hexString.substring(i, i + 2), 16);
                        if (isNaN(byteValue)) {
                            throw "Invalid hexString";
                        }
                        arrayBuffer[i / 2] = byteValue;
                    }
                    return arrayBuffer;
                },

                /**
                 * bytes -> hex string
                 * @param {Uint8Array} bytes
                 * @returns {string}
                 */
                stringify: function (bytes) {
                    const hexBytes = [];

                    for (let i = 0; i < bytes.length; ++i) {
                        let byteString = bytes[i].toString(16);
                        if (byteString.length < 2) {
                            byteString = "0" + byteString;
                        }
                        hexBytes.push(byteString);
                    }
                    return hexBytes.join("");
                },
            };

            /**
             * Translates between utf8 strings and Uint8Array bytes.
             */
            const UTF8Encoder = {
                parse: function (str) {
                    return new TextEncoder().encode(str);
                },

                stringify: function (bytes) {
                    return new TextDecoder().decode(bytes);
                },
            };

            /**
             * Salt and encrypt a msg with a password.
             */
            async function encrypt(msg, hashedPassword) {
                // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
                // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
                const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

                const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

                const encrypted = await subtle.encrypt(
                    {
                        name: ENCRYPTION_ALGO,
                        iv: iv,
                    },
                    key,
                    UTF8Encoder.parse(msg)
                );

                // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
                return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
            }
            exports.encrypt = encrypt;

            /**
             * Decrypt a salted msg using a password.
             *
             * @param {string} encryptedMsg
             * @param {string} hashedPassword
             * @returns {Promise<string>}
             */
            async function decrypt(encryptedMsg, hashedPassword) {
                const ivLength = IV_BITS / HEX_BITS;
                const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
                const encrypted = encryptedMsg.substring(ivLength);

                const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

                const outBuffer = await subtle.decrypt(
                    {
                        name: ENCRYPTION_ALGO,
                        iv: iv,
                    },
                    key,
                    HexEncoder.parse(encrypted)
                );

                return UTF8Encoder.stringify(new Uint8Array(outBuffer));
            }
            exports.decrypt = decrypt;

            /**
             * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
             *
             * @param {string} password
             * @param {string} salt
             * @returns {Promise<string>}
             */
            async function hashPassword(password, salt) {
                // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
                // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
                let hashedPassword = await hashLegacyRound(password, salt);

                hashedPassword = await hashSecondRound(hashedPassword, salt);

                return hashThirdRound(hashedPassword, salt);
            }
            exports.hashPassword = hashPassword;

            /**
             * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
             * compatibility.
             *
             * @param {string} password
             * @param {string} salt
             * @returns {Promise<string>}
             */
            function hashLegacyRound(password, salt) {
                return pbkdf2(password, salt, 1000, "SHA-1");
            }
            exports.hashLegacyRound = hashLegacyRound;

            /**
             * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
             * remember-me/autodecrypt links, we need to support going from that to more iterations.
             *
             * @param hashedPassword
             * @param salt
             * @returns {Promise<string>}
             */
            function hashSecondRound(hashedPassword, salt) {
                return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
            }
            exports.hashSecondRound = hashSecondRound;

            /**
             * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
             * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
             *
             * @param hashedPassword
             * @param salt
             * @returns {Promise<string>}
             */
            function hashThirdRound(hashedPassword, salt) {
                return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
            }
            exports.hashThirdRound = hashThirdRound;

            /**
             * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
             *
             * @param {string} password
             * @param {string} salt
             * @param {int} iterations
             * @param {string} hashAlgorithm
             * @returns {Promise<string>}
             */
            async function pbkdf2(password, salt, iterations, hashAlgorithm) {
                const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

                const keyBytes = await subtle.deriveBits(
                    {
                        name: "PBKDF2",
                        hash: hashAlgorithm,
                        iterations,
                        salt: UTF8Encoder.parse(salt),
                    },
                    key,
                    256
                );

                return HexEncoder.stringify(new Uint8Array(keyBytes));
            }

            function generateRandomSalt() {
                const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

                return HexEncoder.stringify(new Uint8Array(bytes));
            }
            exports.generateRandomSalt = generateRandomSalt;

            async function signMessage(hashedPassword, message) {
                const key = await subtle.importKey(
                    "raw",
                    HexEncoder.parse(hashedPassword),
                    {
                        name: "HMAC",
                        hash: "SHA-256",
                    },
                    false,
                    ["sign"]
                );
                const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

                return HexEncoder.stringify(new Uint8Array(signature));
            }
            exports.signMessage = signMessage;

            function getRandomAlphanum() {
                const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

                let byteArray;
                let parsedInt;

                // Keep generating new random bytes until we get a value that falls
                // within a range that can be evenly divided by possibleCharacters.length
                do {
                    byteArray = crypto.getRandomValues(new Uint8Array(1));
                    // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
                    parsedInt = byteArray[0] & 0xff;
                } while (parsedInt >= 256 - (256 % possibleCharacters.length));

                // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
                const randomIndex = parsedInt % possibleCharacters.length;

                return possibleCharacters[randomIndex];
            }

            /**
             * Generate a random string of a given length.
             *
             * @param {int} length
             * @returns {string}
             */
            function generateRandomString(length) {
                let randomString = "";

                for (let i = 0; i < length; i++) {
                    randomString += getRandomAlphanum();
                }

                return randomString;
            }
            exports.generateRandomString = generateRandomString;

            return exports;
        })());
        const codec = ((function(){
            const exports = {};
            /**
             * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
             *
             * @param cryptoEngine - the engine to use for encryption / decryption
             */
            function init(cryptoEngine) {
                const exports = {};

                /**
                 * Top-level function for encoding a message.
                 * Includes password hashing, encryption, and signing.
                 *
                 * @param {string} msg
                 * @param {string} password
                 * @param {string} salt
                 *
                 * @returns {string} The encoded text
                 */
                async function encode(msg, password, salt) {
                    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

                    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                    // it in localStorage safely, we don't use the clear text password)
                    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                    return hmac + encrypted;
                }
                exports.encode = encode;

                /**
                 * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
                 * we don't need to hash the password multiple times.
                 *
                 * @param {string} msg
                 * @param {string} hashedPassword
                 *
                 * @returns {string} The encoded text
                 */
                async function encodeWithHashedPassword(msg, hashedPassword) {
                    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                    // it in localStorage safely, we don't use the clear text password)
                    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                    return hmac + encrypted;
                }
                exports.encodeWithHashedPassword = encodeWithHashedPassword;

                /**
                 * Top-level function for decoding a message.
                 * Includes signature check and decryption.
                 *
                 * @param {string} signedMsg
                 * @param {string} hashedPassword
                 * @param {string} salt
                 * @param {int} backwardCompatibleAttempt
                 * @param {string} originalPassword
                 *
                 * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
                 */
                async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
                    const encryptedHMAC = signedMsg.substring(0, 64);
                    const encryptedMsg = signedMsg.substring(64);
                    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

                    if (decryptedHMAC !== encryptedHMAC) {
                        // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
                        // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
                        originalPassword = originalPassword || hashedPassword;
                        if (backwardCompatibleAttempt === 0) {
                            const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                            return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                        }
                        if (backwardCompatibleAttempt === 1) {
                            let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                            updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                            return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                        }

                        return { success: false, message: "Signature mismatch" };
                    }

                    return {
                        success: true,
                        decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
                    };
                }
                exports.decode = decode;

                return exports;
            }
            exports.init = init;

            return exports;
        })());
        const decode = codec.init(cryptoEngine).decode;

        /**
         * Initialize the staticrypt module, that exposes functions callbable by the password_template.
         *
         * @param {{
         *  staticryptEncryptedMsgUniqueVariableName: string,
         *  isRememberEnabled: boolean,
         *  rememberDurationInDays: number,
         *  staticryptSaltUniqueVariableName: string,
         * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
         *
         * @param {{
         *  rememberExpirationKey: string,
         *  rememberPassphraseKey: string,
         *  replaceHtmlCallback: function,
         *  clearLocalStorageCallback: function,
         * }} templateConfig - object of data that can be configured by a custom password_template.
         */
        function init(staticryptConfig, templateConfig) {
            const exports = {};

            /**
             * Decrypt our encrypted page, replace the whole HTML.
             *
             * @param {string} hashedPassword
             * @returns {Promise<boolean>}
             */
            async function decryptAndReplaceHtml(hashedPassword) {
                const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
                const { replaceHtmlCallback } = templateConfig;

                const result = await decode(
                    staticryptEncryptedMsgUniqueVariableName,
                    hashedPassword,
                    staticryptSaltUniqueVariableName
                );
                if (!result.success) {
                    return false;
                }
                const plainHTML = result.decoded;

                // if the user configured a callback call it, otherwise just replace the whole HTML
                if (typeof replaceHtmlCallback === "function") {
                    replaceHtmlCallback(plainHTML);
                } else {
                    document.write(plainHTML);
                    document.close();
                }

                return true;
            }

            /**
             * Attempt to decrypt the page and replace the whole HTML.
             *
             * @param {string} password
             * @param {boolean} isRememberChecked
             *
             * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
             *   expose more information in the future we can do it without breaking the password_template
             */
            async function handleDecryptionOfPage(password, isRememberChecked) {
                const { staticryptSaltUniqueVariableName } = staticryptConfig;

                // decrypt and replace the whole page
                const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
                return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
            }
            exports.handleDecryptionOfPage = handleDecryptionOfPage;

            async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
                const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
                const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                if (!isDecryptionSuccessful) {
                    return {
                        isSuccessful: false,
                        hashedPassword,
                    };
                }

                // remember the hashedPassword and set its expiration if necessary
                if (isRememberEnabled && isRememberChecked) {
                    window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

                    // set the expiration if the duration isn't 0 (meaning no expiration)
                    if (rememberDurationInDays > 0) {
                        window.localStorage.setItem(
                            rememberExpirationKey,
                            (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                        );
                    }
                }

                return {
                    isSuccessful: true,
                    hashedPassword,
                };
            }
            exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

            /**
             * Clear localstorage from staticrypt related values
             */
            function clearLocalStorage() {
                const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                if (typeof clearLocalStorageCallback === "function") {
                    clearLocalStorageCallback();
                } else {
                    localStorage.removeItem(rememberPassphraseKey);
                    localStorage.removeItem(rememberExpirationKey);
                }
            }

            async function handleDecryptOnLoad() {
                let isSuccessful = await decryptOnLoadFromUrl();

                if (!isSuccessful) {
                    isSuccessful = await decryptOnLoadFromRememberMe();
                }

                return { isSuccessful };
            }
            exports.handleDecryptOnLoad = handleDecryptOnLoad;

            /**
             * Clear storage if we are logging out
             *
             * @returns {boolean} - whether we logged out
             */
            function logoutIfNeeded() {
                const logoutKey = "staticrypt_logout";

                // handle logout through query param
                const queryParams = new URLSearchParams(window.location.search);
                if (queryParams.has(logoutKey)) {
                    clearLocalStorage();
                    return true;
                }

                // handle logout through URL fragment
                const hash = window.location.hash.substring(1);
                if (hash.includes(logoutKey)) {
                    clearLocalStorage();
                    return true;
                }

                return false;
            }

            /**
             * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
             * try to do it if needed.
             *
             * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
             */
            async function decryptOnLoadFromRememberMe() {
                const { rememberDurationInDays } = staticryptConfig;
                const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                // if we are login out, terminate
                if (logoutIfNeeded()) {
                    return false;
                }

                // if there is expiration configured, check if we're not beyond the expiration
                if (rememberDurationInDays && rememberDurationInDays > 0) {
                    const expiration = localStorage.getItem(rememberExpirationKey),
                        isExpired = expiration && new Date().getTime() > parseInt(expiration);

                    if (isExpired) {
                        clearLocalStorage();
                        return false;
                    }
                }

                const hashedPassword = localStorage.getItem(rememberPassphraseKey);

                if (hashedPassword) {
                    // try to decrypt
                    const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                    // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
                    // the user fill the password form again
                    if (!isDecryptionSuccessful) {
                        clearLocalStorage();
                        return false;
                    }

                    return true;
                }

                return false;
            }

            async function decryptOnLoadFromUrl() {
                const passwordKey = "staticrypt_pwd";
                const rememberMeKey = "remember_me";

                // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
                // since it sends the hashed password to the server which isn't needed)
                const queryParams = new URLSearchParams(window.location.search);
                const hashedPasswordQuery = queryParams.get(passwordKey);
                const rememberMeQuery = queryParams.get(rememberMeKey);

                const urlFragment = window.location.hash.substring(1);
                // get the password from the url fragment
                const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
                const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
                const rememberMeFragment = urlFragment.includes(rememberMeKey);

                const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
                const rememberMe = rememberMeFragment || rememberMeQuery;

                if (hashedPassword) {
                    return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
                }

                return false;
            }

            return exports;
        }
        exports.init = init;

        return exports;
    })());
    const templateError = "Incorrect Password!",
        templateToggleAltShow = "Show password",
        templateToggleAltHide = "Hide password",
        isRememberEnabled = false,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1b0b327e51d2a821a9ae064e92e0037c21d07f314d1dad658ffbe16457f842c22c8682b899d317487016aaae85acf8870c8155e207f88974f580998646d1d2e04e4dd579792e6e9ee97ec734857d498d53ddd92aafe21cb444c14fb3440c4cf8aae40accfa0bf2bbf6459295e2e61f3e63cb1f8d82e76c61d40cf4734428963444be2318ca691a9b6906852cb4d2147487dce5fcd0bfdb890b5f5bd864045ba4c2120667d0fd89c79555414f7172da6471037b57dd97f6c247bf88310a8027e92685696e0c00733c23fdeaea0ee02bb31e912e2a61cb29c16b52a79fd6cbe6382d1eea8440f89803327adb24cbd5658fb24a9d09f4eb4a374fe4c887940cca83a62417acdbd7b510629f5984dd55d64b1731d2675b0ff84a9821fb601ff2b6a844c05eb25df345881cd11acec851f444dc3059067f37f3a69c1fe11c51a7b6c4a932e43d0ba684d412caf0ca85b30709f80d15d68774f4031ce81c06718541f5c1fba89af297ec8bc500056c9cf976792169cbe2cfa0524e564a9b820122e810f5d85fe8e0d2df710a31432923d423f9bc7fd0a7706ce213655af53ec2c05cbd08ce94c0e28f259bed86b6746bfa6c6a5cc405d544deacad927c21f778194a5aab0e80c9fc0fdcfb78a9b33bc7df416bb041ef8ea1334a76c4d9431e20a55c730a4fa55b05a86a6576246430d339387a5d8c96c7d75fd64911f48365cde2a6172b6594536f7afd4a929c47ca3adb16e68140d5d24e706635e5256d3d38f1bcd70ae1faae4d51fe92a37e9bb3f58ee4fd5746e380fcda97bb751283170a400cb84100131438e70b0df4866387877025261a79de8d281e03c5541e015719468f736133aaf92e42aacdeeb54182f2bf8a5accb3f490d34f11a12293ab11c0cf2653e2e685eb7654a9079838a155da7a44b26265df4be6a1576386785744061ef0841130bb696d306f037cadb0e6313012e8e3e3bfa1dcc347013154304911b8d77c93d5f03eaad852c78c6a93c3006ca2b746cab5e689907e492adf4d683e743b34cbd9d3aed26fa9ed127d1626497a3e0ba5dd0c3883055d284012b0ec48a5d2ad4c2f06fd021e5a144ababb048bf8d095ad6513c2050784e773c4c0e0372c901d461ea5b077da8ce63a8268d042c5f77239850bd2c18e66c5584844b6962e7fcebec5ce08489ebef5e1bd639eafed9eea72ed8032b31a7ba2bdfe21a6185118f6101eb70366240580cc5a6b2aa18bb28ec5ba1b9e9c397203a84ffd42c0b2c59df78ca8fb7874d3316aabb0b283f8e95c6e9cd86c6d556ec81f3365048556c925e4c77439ac023fc6552601e2d02dd54bc8e37b2ba712025e9b4532991015062ed5d3951684edb65565c8c27781901a3ef13f9f53fefd6993df1750a19d5a8c8dcb1bfab10b87079f508e54e3c3d9b8e46886cdb1ed4c049655140ef39e6be7d4a2a907c23bf7dbf29b6ff45f3f59c52632e5ff715ad69c75865e038642b3bb2b2adc54aa0be1374b8826dc3aeb041de95a2395408b0c183d49b19a2390fc0249f404785b0a657f3a9e832b4b50edd515497cccaceefc2b67b5ed1e39eafd3be7e246424baf5af0960ed006c48f5437b3c9272f61c5bd45d71f96a977d0a320432e5edc3d52f92bdc58d07ada80cf5c64154a73aacdb12f353859f360047fd4acde5179d83af6ede358360c7bba2beb5954682b0b0c7a18b146c55a6e8dc1997cb99ffcfaf34f313494a21a2576a62ffcf9ca3f850af8410e438c628e73164bacbb62662e56b30deb032b0112f7511148f98ba7084e9aff06657196f3fb4315a92ceb55f4fcc2c97289b445fdcdffbd7f8d53c74fbe1ebc0f47219ec877b9914f170cbfd124b6c966c12a993fbb9f7652750da6a23aa7e89684b1e5ae8dd1daf681c430074edd7e68fb4ab9a59f9c6b5dbac5c48695047f704b8ac5d93b26f02ef3951138fee029e1466c0712a442935ded68dff011753ab6d26ccee7940dba4d0a779d09e211ef2333d344ec30632b7e93e923c69377765de9e12dd4b98743899352df27a3c37f034ec83bfb56a2c4019a489df370c466df51f6af0adeb76cadc928b51da19e7a83d6d9f6f7245184fe884505c7de14e08cb200064a50c8c2e3d79d60042dcec2d41b98d2ede6d463f080eb9f0b7f0988ab832c4e55d24a98e7cd2a6f6a95e152b3265f50269816bdf9f2cc300a9009db82d74453063f984d345f0aff57bbcac0a35c9ddcfb0ef8c92a928805bee55348442967c452a815b4943232e8b37e76f1934535ab906eaabe4acd751823f7873ebc6a57d7b13d4a09af91f34e1c516a39c94ab58a9e147eb99936892e2d38c0f2c3ddfb69c4de420ffd975f0e1fa66147d54c147fb0e8c0293d423ee5d8029e6cad35eb9415dd864b7ba5a34719d777019072b7857213d7471eda6b27abaf6b19ccb739fe3b16b7c88821cc444eb8f93afbdb379fbbe7c0c9b9bd376f24b3775e7a27dd6b8f8e70b1af3bcce1efaabf7712c8b11641dafa22d2363aad8d68eba0b4c6ecefc3b150323c734527b831d9785caab7d952c6a34609f28b3587d17dbc836d1e0eb85aa3752084b274bb9e57c30e5e053133c51f16f119a38752d303b4559ddd6a2d07c2b59b7f49eac26d66f822f2274ade59ff45e38050eb40edf6c35ba9a3c51d287c349a69fe1ec7679b5db36ca9bb8218621a2e5c2246b3eebb5ea913baa64ac7f1db75ab2e857f00fa69d2e7cf9ed53c72bfadb673ca51d94fdc803d8f7fbbc497e1b9a60fcf2e97fb21a0edb2de40a56a5d21ffaf13a6c4bb21d3df4ddfd0523fde2e871927d83dd42ceca1c2423b6bc9a73ab07e73c0b459f0ef6b153e8b84a6bacd673562e5694a83b707664def70a9c3bcd1b598d3732b9fb79e809f48914b759c76111fe9f6d0189acb97242dbc7496065ab35c943545d06a5cffac971c3a60be1769f3728d19e08ff7ac511904fd65766c9a9eb26652ab1f1ad64a3a06cb069bd00f94f311396729402c07b7616ae16d68c9563c2b225e61bf2cecceed0c4e52fb161771cf49a4db50a7b1ca9db09338ed8b477c2156beb64e4c1ccaa96fa4f6eba565265ea2e5adb22dc479951e28958e527c381c3b2cb5ca50734ec8c7f3eee9e79deb96ea63255d6d80ccb8501ddbdd55a3502a2dd4abbc00da15fabdc26973e100ae9d52df7359474f25b1593102fa36f0d292212c8acba0510ed5600dbaa699de18cc5154586ae3041e2c02ff676389588f46f5ee4939dfcdfa1ebaecfb3824fb2949d6ac1591f00d8610dd7908bbea418e26519c7b4ce8a20f500c403fd0420b8487b9f73f0084e6f0ceb3caf128e4f90c3cec9a68b1be66f4d0e1a4acf24a07f41406eeb599710dc24b83ed4ead0d3eda7d5a6e4fef6589e49cf0825e83fc979b72e88dd8284764e426093205a61d2d4687301b57fa232e6d52c2e27209110f9e3252c0b6546bb7bcf73d5cf33cb201856502ee8c07551f7d56ca9f9deeaf84e336f1d61e1bcd1c348c133db841ae889d2a9a2e40539411fc7b5f1a97a5feb112cdc809453fff31b9abb48eecad4dc1765fe97e7318fb75285786860a1185165446f6769ccd6a9765b5dd993abdb92374e8a128fecb695b4a2fc2b7f6ec29aa994d7e80c72c526fc8849e3285ac321064a2e0f79aa12d85febf6b2d9719074792a1d0129368e8f94fa5779ad2305d4e8dec50ec83645307aa4361ceac92a0133be8a9f066a4b33f269675241bf272f251a2680aca801f5fc1dcdb61bd614e3c3bc56fa4062f6f2c1b90dccfddd7eb3336062008b8c3e0354318f7b62f37075f9d17713b301fc7ff5c89728b40b665e46153d5a911f7b7084213723f076388f0dda41d1f5a1d8875409d46603fb1feb16cbca1c6af8fa762dce810e4dea1dc5b9f484c05055db936cd411c1930e86dd119a3b43ae63c0a688270d78a9b0855021e7b86aaf78cbe1e2efc3c2f854867c1f413516531d8d08cd3949c7bb317cf85a6d2598b879553b6a41b701a1871986cccbcdd58bdd023110174f32e050b5e71575f376e62bdd43399f5b2b32280484555c8d43f17c898ee5fee8b52c0c433a49fef31f3c69a6f9ce591f35b350be5d40983d84e15e226e874cea0686c10b7b80e0f4cfd413c4ab670b777fed02b496fa8a77adb4cfeabfb451ef1129f24075fb24896f5b5f89302130547626ebcd97a31cd1fe8de0ec5c615b1e4bbef4ebd167c12e3088be16ddd13e47a08c308b88af7a2c801dd7d53dcf00902e63c6b11ca4db362d70fd9a1dac4769d42712791266980bf70bd3ea48162804175248466a414f25bcc2511f1f52dc544b70a2a1d4e6121b798bc26411e004578729915078cdc794a6402684aad119c4608f63eabdc562b2403103131fab2d93841829bf124fdc0fc294b9a626c9b31fd56fbc63e68bcb3b7bf1fd0637289e89ece4c0203210d342ed6e691e6ffa92490f40d8d9447983d2c00d3dc45703257811d422aeca8e5d99f129cd6196835ad987d3bc2724119ba0f4dc7f7e02054522b2221ca1a85df2197102f90de2c53c01a8bb353ae5ce8cf0b1a153457f8610194f9a3a52cc1e11f16bfd0d109f398acb18ec01db1238c5dc39ee8130a81c4741c559691a543b0e5f99a717906822dd5b4bc829cc57fa6a40e1a1d4ce98d28d007491af2ab1ace63b08091f70423c8945e9d3f6a697dc8b02c045e086c13a1c42f968db48c00b96fa4efb08168d70633440a8c7299c36d6d77b04c0394f935ef5682433d4f778eb5f6007d2c8e7342a2b55ff2704df4bc4e75e5cb9fbf736344fb2b161d1711e6f8cdde1701bc08e63aa3b0c559b1888782ad362b91ee74571a049777c807f66f12ee76835d72ee2b4a00fcdc367a3b72ffd287f8961c02cee5c817e35f861bc2939eb67a0baba205ed01a547df139266c96196e299a9615c89da79ee97dca7517aea9ec1bee043f414ab0460f0bf3f705af36575a97ecd83feb835cb44b7c850c7d71c7cb39a630272466cef381f6b847c5d40843454abd0be4c8a7dfac9d3156eadbce771fe5d28607e687ff633beb6545809aa2d1d1eef700b09fa13c9849c37a7d2e2b43895aa9d166529b49ed72fb884f820c68df3a7b5fd5f993a2524061e4a946566f5cd3067ab43a5f0018e53af91135aa1573291f533950355cc89418f6fb7ed6842e6eefe0a127f838f0199ee222494dc44968cad5fb6393c7b772a6221cd6c0aba07421ee8dadfd93464b117eac31082f847ff61a46eb3c0fa366029c11509d166fef4e61be267123e4a0ec789ba6331fb3caa8bfedddb4eb2f65ae531e26392917e09536022fbecff2f89268964628bd403de31ed61e584c90bbca2f384c460c4499b27ae0db656aea98d068fcab32234c16def1a3646736a00b65ddced076aa5c1fa865cda220fc81b0a9c087a7c3ce5923d355b2045cc9298539d041232d1192212f41eb1b9e84b1654e885a2534e3bbcc0637e8d789de9801642e2e1a48ce6a55f87023b4de3e1819e6d2d589cbfbee2acd27f2917bc7058bae7b9becd971a1d6e90dc524c29755ec275f26e01bebc1b7715185979764722b8786473b74e7b89ff07fcc210644d7920e66d30df5ff53d547417aea6209f28035d2848c1b425b37940d11512ec00ac99a363e3a504ebf88ced51af2530df847584f4bd9e4b938ff2c686050fe02438933f99239eb26ff8fc4d6b70cc212dc99196f227ca458e7210845fc454f4adb2beeebb0df765b4f7aa630b0cd98c3f73211f094fb8a2435ea8ab1ecaacf4ec521a6abc4a3ad8a02dc0f34ad8fd43571e997cf406464dcb9e55a99b1c682ee582ae8df265523b0481b2716a076b563de1594ff0b182d8969829f71d0b8f2c302283375e908f78dfab4fc13d308e1489c81ab934b52f0ccfd0e7aeb622e9c383921e1e363fa3b5de124f4fe6a28339536a0c3102d3aa9f8b547457f2c3b4e6c8d0e545e6823c376e05106bd9746d5c81d3f356aa15979c56d7a4b4183d550278263aeda415d5198e74349a0a99f0c6799644e51100e905ac8b4b479aa5b50c5118bac58e669f2246f7dfbe7b12b7769aed115a7ff80e8131975a09279d84c62fef852f6ebbf330847bb1f360565b07db741df275b77175c2b5141db868eaabb7403d11a18f81d2d90360c71cf897e57e5d44a5b9b584f66796b781b156326d0b26b0730c05bb32980bef0fb2165ae16418f04e1d84201efc0c529524fdcd3769ec5ccea9ac9999aa810be4d2711ae10b4b309cd231d47d5b752397579e49f6549f0dd146d1b3de35a0784cdffa34c6f9c434bc216624de54240a9418862d1e4059ad4e002cf07d8076fdda2f1d6132864d16fa8c4adb161f04ac5d41968b99ca5b5eb41d1475b77013c6352a1af768b4fb42d957cc1b554ff4a670ae5a599354da72f53baf02587f31c9e3b136f96fff4f2e90120156b287eae82a5419989b8ebe89bdc08329b45d9f13177eb9d1438e2bfb9f2d4ac0ed8563a995032f5c6114e19051e89a133e47900d70dea74cfc4e729f1dd6082a6de676bd792976b3aa677c7759119c4d160d263853d37089210c7919b4ee79985d293e2d1389aa73298693bb751223ad10b299b7036051c5b8e4fb39b475cea87e94769e65d12b9077995ea687e81dd442a303d86233a269cb182fa4eb0a410ffb7e626f69b4e6ffc27160b794848b9952cf32bb64d3c1d6507843899bc1581ad5d00579f2b352bcd855e6c086212d1cb3d92465b566f70163310e035b1e67e8593786227594d6cfe1bb464b099894dcf0f87bd4fb3bb2deac4c3350fe3db697be65c82f9942442705d24cd816b77cc21f7dc5d2f5790fc6cf2564cf03522d0c44e60caa0f5c124d88b4e83e5be06d6aeccf91d83cc3f15dbca2a1f1fd5b95a4f5e1cd416e31fea7745b9bf87b79c57a27275a51db51a491ff56df7ef15c6916df965ecf61852532e6671fba829eb4ce92fbd447209a92cade55e8b716e53746d5588310be3aa7baefc7cda8bcc16a1c6031b01bd91a733d84c371de8f3add2f5ce31720ab51834083bf34b276e27b83349c8c616100a9f8e35942da4bbeb99b3dc511b5f61a0f7ea8f3583505ff096abf6958b348808c60af923c61ba6fc7affcc5b19bc1149e4f0d93a88b61ff6acf51cccd2f4e34172c7d6e627672bb0291a293c547a64c174848f77e57bf0e65fa4a5bafa6e621f1c48c936ebb87f17ed2a17eedcc521ca1283cc68b847e00b5f839ba42a0a60c455330a5122881cea280f4563e6040d706afd5595a8965be681adb5a4fa5466707baf97da67b1a666190805d6e4b074f3116183c6d80cfaaa53566cec4720d8165da0d1b07504b9427ada561bf787add2e29de9fee32dcdaa938089504b87b0c7c37beb0bc70c9316cdc15728d38465ca6e7ab627319776580604910558762a323d19b2cd66a31d6be13169bc558df9047be9d21e4fe3d5ab25ad624ec207ffc7ae6fce18b44b9c879b43245131c8878b606cc95dd6208f9032b775fa0aed70e1324e1171cb9f898fbe78ed6b4838da53b506b3fbfd09728dbac7d56e1f23769019b0fe59860b56836c628a10561f25df1d4d691a6ef85771c01aba57fdaf0beb41ddaa0a28fdf36436939e952f169e667dca0f996405bd3f533fef89da35ed64a0fd0e6a50c5e6bdc81fc98d45b53c47e0e20b56abd54c758871dc8a6fa481d265fe53d697974a933dfd07281c94cb7ca1311b8d6cee88b0d7ca18bd299f28007445cd0373bf200e69d8866aa48bcf5711f3f0d469819d466f54bd59b7366d9806e8c3fe1aa4294c7fb93d465156a64b3485fa43d02dfce1c5b10a778a5c2f14d50722315b2c7bf0d28f55a949551bdbfa46a2bd5d14964308df37ff395e4a2378ae488aae59afcc2efc7db9751597848e367eef84dd6069b39d7bd3c392f86390eeb51ad7e4b7646135770645c9af1ecd2a434106b6c54b6bd03da17fb31d369bb6f5dccdcfac9c23ea4e3b20be419089ccf7796a619fc08d8bd292f414260ce8060af992065a9bf0286ad426b9d2c02d4d245bb6cc0b49d8efa32a4ef23807fbf988a120e334b5a9883d8e5601b854fbc8413b32253ae724e52df6e2a4c4a772d4f2c212e80a855a34100e0eb3e2e9b2772c2be51869ff83472216113cf78cdc13bb60cdfa1e59a6c8260b067d997bd1a773839b6d93aee23b24d6b42238416645c75d052e26d02da7f684b55a3d08513d269906e507147899820f0c3a904e46526ea1566365157b22e0625144429a02dbe4d35bb928c33c191d99d9fcd5de5a25379e890291d4c6a111ca30d32c8911f89b93ab6a144aeaf6be1bb6817c55035e82818f24a1fdc6741c6b55484c7397f4db331086cd39a5d76e5ba5fb82afaeb9316b116f7382666ba634b762961339699de97cdc016533d184d6fb7b3aa00cdf8229b611e926e585e794ce63736230087aa131c5df420f763191b219cf40626bb98fe28d01707fbca762ec84303c57f559bab2f8e95e6d2196d029d5cb7fd18e581d2052113252ef297df146eeca8d3e8bfc4cd633d776f1a6aea39ab694bddb71ceeae68a9acf9ace444d728cacd08df1b782c029b044da5dba18e2995534219332d4f0302e160346698d296adc19e3a933e676034b4e1ebaa742b946ae25299c374246b5652bdd55c01a8797a9e5b88cc7d6cf646776de530faceec1718609aae2c7e9462df83a0497823e5e7e7aa1abd413efab2cf1fd6ec012033760a90b9571cd4599b3f061443c3df9c938b7a89579828181999407a735daea4967ea048a042ade96dfe78cd2adef069f497ffc0bcf799bfb8c71ea25f9577c0af9c0e44e3cccac41ddb1b557558f758b1ba31b7a5956391831dbe91ff888bc071a4c26e8b283269b72366aba51f72ae452f7aeb66957ed8a601a4661ef5d2d118a64ec95a075318917f6088213c6aed918fb1aebd0d8f88884c991c904e90eaeaa0ed96afc2206cf60d478f436b55e42f2421c10c4da8688d00ae66182e8523e1b883","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"934c14950d2a7b4c7dfdf5b951d6ec20"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise, the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById("staticrypt-remember-label").classList.remove("hidden");
            }
        }
    };

    // toggle password visibility
    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    // these two icons are coming from FontAwesome
    const imgSrcEyeClosed = "/images/invisible.svg"
    // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
    const imgSrcEyeOpened = "/images/visible.svg"
    // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
    toggleIcon.addEventListener("click", function () {
        const passwordInput = document.getElementById("staticrypt-password");
        if (passwordInput.type === "password") {
            passwordInput.type = "text";
            toggleIcon.src = imgSrcEyeOpened;
            toggleIcon.alt = templateToggleAltHide;
            toggleIcon.title = templateToggleAltHide;
        } else {
            passwordInput.type = "password";
            toggleIcon.src = imgSrcEyeClosed;
            toggleIcon.alt = templateToggleAltShow;
            toggleIcon.title = templateToggleAltShow;
        }
    });

    // handle password form submission
    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
        e.preventDefault();

        const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
