<!DOCTYPE html>
<html lang="en" class="staticrypt-html">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/images/waving.png" />
    <title>Locked! | Sunny's Website</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #FFC000;
        }

        .staticrypt-page {
            max-width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            /*background: #000000;*/
            border: 2px solid #FFC000;
            color: #FFFFFF;
            width: 60%;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        @media (min-width: 768px) {
            .staticrypt-form {
                width: 80%;
                margin: 0 auto 100px;
                padding: 45px;
                font-size: large;
            }
        }

        .staticrypt-form input[type="password"],
        input[type="text"] {
            background: inherit;
            border: 0;
            box-sizing: border-box; /* This ensures padding is included in the total width */
            font-size: 14px;
            outline: 0;
            padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
            width: 100%;
        }

        .staticrypt-password-container {
            position: relative;
            outline: 0;
            background: /*#f2f2f2*/white;
            width: 100%;
            border: 2px solid #FFC000;
            margin: 0 0 15px;
            box-sizing: border-box;
            color: black;
        }

        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            height: 20px;
            opacity: 60%;
            padding-right: 5px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            /*background: #000000;*/
            width: 100%;
            border: #FFC000 solid 1px;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #FFC000;
            filter: brightness(92%);
        }

        .staticrypt-decrypt-button {
            transition: 0.3s ease-in-out;
        }

        .staticrypt-decrypt-button:hover {
            color: black;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
            /*background-color: black;*/
        }

        .staticrypt-content {
            height: calc(100% - 101px);
            margin-bottom: 0;
            /*background: !*#76B852*!#000000;*/
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        @media (min-width: 768px) {
            .staticrypt-content {
                height: calc(100% - 70px);
            }
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: small;
            margin-top: 10px;
            margin-bottom: -10px;
        }

        @media (min-width: 768px) {
            .staticrypt-title {
                font-size: larger;
                margin-top: 10px;
                margin-bottom: -10px;
            }
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .staticrypt-hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: calc(100% - 101px);
            display: flex;
            align-items: center;
            justify-content: center;
            /*background-color: black;*/
        }

        @media (min-width: 768px) {
            .staticrypt-spinner-container {
                height: calc(100% - 70px);
            }
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid #FFC000/*gray*/;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
    <!-- My own things -->
    <link href="/output.css" rel="stylesheet"/>
</head>

<body class="staticrypt-body bg-n-8">
<div>
    <div class="top-0 left-0 w-full border-b border-colour-7 lg:backdrop-blur-sm h-[101px] lg:h-[70px]">
        <div class="flex items-center px-5 lg:px-7.5 xl:px-10 max-lg:py-4">
            <a class="lg:block w-[60px] xl:ml-2" href="/index.html"><img src="/images/sunnylurking.png" alt="leftlurk"></a>
            <nav class="relative left-0 right-0 bottom-0 ml-auto lg:mx-auto">
                <div class="hidden lg:inline-flex relative flex-col items-center justify-center space-x-20 m-auto lg:flex-row">
                    <a href="/index.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Home</a>
                    <a href="/pages/aboutme.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">About Me</a>
                    <a href="/pages/projects.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Projects</a>
                    <a href="/pages/contacts.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Contacts</a>
                    <a href="/pages/blogs/menu.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Blog</a>
                    <a href="/pages/miscellaneous.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Misc.</a>
                </div>
                <div class="flex lg:hidden text-center">
                    <div class="absolute right-10 hidden w-60 border-colour-7 border-2 rounded-lg overflow-auto" id="navbarHamburger" style="z-index: 10">
                        <ul class="flex flex-col font-medium">
                            <li>
                                <a href="/index.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Home</a>
                            </li>
                            <li>
                                <a href="/pages/aboutme.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">About Me</a>
                            </li>
                            <li>
                                <a href="/pages/projects.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Projects</a>
                            </li>
                            <li>
                                <a href="/pages/contacts.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Contacts</a>
                            </li>
                            <li>
                                <a href="/pages/blogs/menu.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Blog</a>
                            </li>
                            <li>
                                <a href="/pages/miscellaneous.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Misc.</a>
                            </li>
                        </ul>
                    </div>
                    <button id="burg" class="button inline-flex items-center justify-center p-2 w-10 h-10 text-sm text-gray-500 rounded-lg focus:outline-none border-2 border-colour-7">
                        <span class="sr-only">Open main menu</span>
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 17 14">
                            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 1h15M1 7h15M1 13h15"/>
                        </svg>
                    </button>
                </div>
            </nav>
            <a class="hidden lg:block w-[60px] xl:mr-2" href="/index.html"><img src="/images/sunnylurkinginverted.png" alt="rightlurk"></a>
        </div>
    </div>
</div>

<script>
    const burgButtonTemplate = document.getElementById("burg");
    const burgMenuTemplate = document.getElementById("navbarHamburger")

    burgButtonTemplate.addEventListener("click", () => {
        burgMenuTemplate.classList.toggle("hidden");
    })
</script>
<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Locked!</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr" />

            <form id="staticrypt-form" action="#" method="post">
                <div class="staticrypt-password-container">
                    <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                    />

                    <img
                            class="staticrypt-toggle-password-visibility"
                            alt="Show password"
                            title="Show password"
                            src="../images/invisible.svg"
                    />
                    <!--                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="-->
                </div>

                <label id="staticrypt-remember-label" class="staticrypt-remember staticrypt-hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />
            </form>
        </div>
    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
        const exports = {};
        const cryptoEngine = ((function(){
            const exports = {};
            const { subtle } = crypto;

            const IV_BITS = 16 * 8;
            const HEX_BITS = 4;
            const ENCRYPTION_ALGO = "AES-CBC";

            /**
             * Translates between utf8 encoded hexadecimal strings
             * and Uint8Array bytes.
             */
            const HexEncoder = {
                /**
                 * hex string -> bytes
                 * @param {string} hexString
                 * @returns {Uint8Array}
                 */
                parse: function (hexString) {
                    if (hexString.length % 2 !== 0) throw "Invalid hexString";
                    const arrayBuffer = new Uint8Array(hexString.length / 2);

                    for (let i = 0; i < hexString.length; i += 2) {
                        const byteValue = parseInt(hexString.substring(i, i + 2), 16);
                        if (isNaN(byteValue)) {
                            throw "Invalid hexString";
                        }
                        arrayBuffer[i / 2] = byteValue;
                    }
                    return arrayBuffer;
                },

                /**
                 * bytes -> hex string
                 * @param {Uint8Array} bytes
                 * @returns {string}
                 */
                stringify: function (bytes) {
                    const hexBytes = [];

                    for (let i = 0; i < bytes.length; ++i) {
                        let byteString = bytes[i].toString(16);
                        if (byteString.length < 2) {
                            byteString = "0" + byteString;
                        }
                        hexBytes.push(byteString);
                    }
                    return hexBytes.join("");
                },
            };

            /**
             * Translates between utf8 strings and Uint8Array bytes.
             */
            const UTF8Encoder = {
                parse: function (str) {
                    return new TextEncoder().encode(str);
                },

                stringify: function (bytes) {
                    return new TextDecoder().decode(bytes);
                },
            };

            /**
             * Salt and encrypt a msg with a password.
             */
            async function encrypt(msg, hashedPassword) {
                // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
                // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
                const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

                const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

                const encrypted = await subtle.encrypt(
                    {
                        name: ENCRYPTION_ALGO,
                        iv: iv,
                    },
                    key,
                    UTF8Encoder.parse(msg)
                );

                // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
                return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
            }
            exports.encrypt = encrypt;

            /**
             * Decrypt a salted msg using a password.
             *
             * @param {string} encryptedMsg
             * @param {string} hashedPassword
             * @returns {Promise<string>}
             */
            async function decrypt(encryptedMsg, hashedPassword) {
                const ivLength = IV_BITS / HEX_BITS;
                const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
                const encrypted = encryptedMsg.substring(ivLength);

                const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

                const outBuffer = await subtle.decrypt(
                    {
                        name: ENCRYPTION_ALGO,
                        iv: iv,
                    },
                    key,
                    HexEncoder.parse(encrypted)
                );

                return UTF8Encoder.stringify(new Uint8Array(outBuffer));
            }
            exports.decrypt = decrypt;

            /**
             * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
             *
             * @param {string} password
             * @param {string} salt
             * @returns {Promise<string>}
             */
            async function hashPassword(password, salt) {
                // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
                // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
                let hashedPassword = await hashLegacyRound(password, salt);

                hashedPassword = await hashSecondRound(hashedPassword, salt);

                return hashThirdRound(hashedPassword, salt);
            }
            exports.hashPassword = hashPassword;

            /**
             * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
             * compatibility.
             *
             * @param {string} password
             * @param {string} salt
             * @returns {Promise<string>}
             */
            function hashLegacyRound(password, salt) {
                return pbkdf2(password, salt, 1000, "SHA-1");
            }
            exports.hashLegacyRound = hashLegacyRound;

            /**
             * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
             * remember-me/autodecrypt links, we need to support going from that to more iterations.
             *
             * @param hashedPassword
             * @param salt
             * @returns {Promise<string>}
             */
            function hashSecondRound(hashedPassword, salt) {
                return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
            }
            exports.hashSecondRound = hashSecondRound;

            /**
             * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
             * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
             *
             * @param hashedPassword
             * @param salt
             * @returns {Promise<string>}
             */
            function hashThirdRound(hashedPassword, salt) {
                return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
            }
            exports.hashThirdRound = hashThirdRound;

            /**
             * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
             *
             * @param {string} password
             * @param {string} salt
             * @param {int} iterations
             * @param {string} hashAlgorithm
             * @returns {Promise<string>}
             */
            async function pbkdf2(password, salt, iterations, hashAlgorithm) {
                const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

                const keyBytes = await subtle.deriveBits(
                    {
                        name: "PBKDF2",
                        hash: hashAlgorithm,
                        iterations,
                        salt: UTF8Encoder.parse(salt),
                    },
                    key,
                    256
                );

                return HexEncoder.stringify(new Uint8Array(keyBytes));
            }

            function generateRandomSalt() {
                const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

                return HexEncoder.stringify(new Uint8Array(bytes));
            }
            exports.generateRandomSalt = generateRandomSalt;

            async function signMessage(hashedPassword, message) {
                const key = await subtle.importKey(
                    "raw",
                    HexEncoder.parse(hashedPassword),
                    {
                        name: "HMAC",
                        hash: "SHA-256",
                    },
                    false,
                    ["sign"]
                );
                const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

                return HexEncoder.stringify(new Uint8Array(signature));
            }
            exports.signMessage = signMessage;

            function getRandomAlphanum() {
                const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

                let byteArray;
                let parsedInt;

                // Keep generating new random bytes until we get a value that falls
                // within a range that can be evenly divided by possibleCharacters.length
                do {
                    byteArray = crypto.getRandomValues(new Uint8Array(1));
                    // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
                    parsedInt = byteArray[0] & 0xff;
                } while (parsedInt >= 256 - (256 % possibleCharacters.length));

                // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
                const randomIndex = parsedInt % possibleCharacters.length;

                return possibleCharacters[randomIndex];
            }

            /**
             * Generate a random string of a given length.
             *
             * @param {int} length
             * @returns {string}
             */
            function generateRandomString(length) {
                let randomString = "";

                for (let i = 0; i < length; i++) {
                    randomString += getRandomAlphanum();
                }

                return randomString;
            }
            exports.generateRandomString = generateRandomString;

            return exports;
        })());
        const codec = ((function(){
            const exports = {};
            /**
             * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
             *
             * @param cryptoEngine - the engine to use for encryption / decryption
             */
            function init(cryptoEngine) {
                const exports = {};

                /**
                 * Top-level function for encoding a message.
                 * Includes password hashing, encryption, and signing.
                 *
                 * @param {string} msg
                 * @param {string} password
                 * @param {string} salt
                 *
                 * @returns {string} The encoded text
                 */
                async function encode(msg, password, salt) {
                    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

                    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                    // it in localStorage safely, we don't use the clear text password)
                    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                    return hmac + encrypted;
                }
                exports.encode = encode;

                /**
                 * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
                 * we don't need to hash the password multiple times.
                 *
                 * @param {string} msg
                 * @param {string} hashedPassword
                 *
                 * @returns {string} The encoded text
                 */
                async function encodeWithHashedPassword(msg, hashedPassword) {
                    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                    // it in localStorage safely, we don't use the clear text password)
                    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                    return hmac + encrypted;
                }
                exports.encodeWithHashedPassword = encodeWithHashedPassword;

                /**
                 * Top-level function for decoding a message.
                 * Includes signature check and decryption.
                 *
                 * @param {string} signedMsg
                 * @param {string} hashedPassword
                 * @param {string} salt
                 * @param {int} backwardCompatibleAttempt
                 * @param {string} originalPassword
                 *
                 * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
                 */
                async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
                    const encryptedHMAC = signedMsg.substring(0, 64);
                    const encryptedMsg = signedMsg.substring(64);
                    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

                    if (decryptedHMAC !== encryptedHMAC) {
                        // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
                        // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
                        originalPassword = originalPassword || hashedPassword;
                        if (backwardCompatibleAttempt === 0) {
                            const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                            return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                        }
                        if (backwardCompatibleAttempt === 1) {
                            let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                            updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                            return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                        }

                        return { success: false, message: "Signature mismatch" };
                    }

                    return {
                        success: true,
                        decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
                    };
                }
                exports.decode = decode;

                return exports;
            }
            exports.init = init;

            return exports;
        })());
        const decode = codec.init(cryptoEngine).decode;

        /**
         * Initialize the staticrypt module, that exposes functions callbable by the password_template.
         *
         * @param {{
         *  staticryptEncryptedMsgUniqueVariableName: string,
         *  isRememberEnabled: boolean,
         *  rememberDurationInDays: number,
         *  staticryptSaltUniqueVariableName: string,
         * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
         *
         * @param {{
         *  rememberExpirationKey: string,
         *  rememberPassphraseKey: string,
         *  replaceHtmlCallback: function,
         *  clearLocalStorageCallback: function,
         * }} templateConfig - object of data that can be configured by a custom password_template.
         */
        function init(staticryptConfig, templateConfig) {
            const exports = {};

            /**
             * Decrypt our encrypted page, replace the whole HTML.
             *
             * @param {string} hashedPassword
             * @returns {Promise<boolean>}
             */
            async function decryptAndReplaceHtml(hashedPassword) {
                const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
                const { replaceHtmlCallback } = templateConfig;

                const result = await decode(
                    staticryptEncryptedMsgUniqueVariableName,
                    hashedPassword,
                    staticryptSaltUniqueVariableName
                );
                if (!result.success) {
                    return false;
                }
                const plainHTML = result.decoded;

                // if the user configured a callback call it, otherwise just replace the whole HTML
                if (typeof replaceHtmlCallback === "function") {
                    replaceHtmlCallback(plainHTML);
                } else {
                    document.write(plainHTML);
                    document.close();
                }

                return true;
            }

            /**
             * Attempt to decrypt the page and replace the whole HTML.
             *
             * @param {string} password
             * @param {boolean} isRememberChecked
             *
             * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
             *   expose more information in the future we can do it without breaking the password_template
             */
            async function handleDecryptionOfPage(password, isRememberChecked) {
                const { staticryptSaltUniqueVariableName } = staticryptConfig;

                // decrypt and replace the whole page
                const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
                return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
            }
            exports.handleDecryptionOfPage = handleDecryptionOfPage;

            async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
                const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
                const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                if (!isDecryptionSuccessful) {
                    return {
                        isSuccessful: false,
                        hashedPassword,
                    };
                }

                // remember the hashedPassword and set its expiration if necessary
                if (isRememberEnabled && isRememberChecked) {
                    window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

                    // set the expiration if the duration isn't 0 (meaning no expiration)
                    if (rememberDurationInDays > 0) {
                        window.localStorage.setItem(
                            rememberExpirationKey,
                            (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                        );
                    }
                }

                return {
                    isSuccessful: true,
                    hashedPassword,
                };
            }
            exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

            /**
             * Clear localstorage from staticrypt related values
             */
            function clearLocalStorage() {
                const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                if (typeof clearLocalStorageCallback === "function") {
                    clearLocalStorageCallback();
                } else {
                    localStorage.removeItem(rememberPassphraseKey);
                    localStorage.removeItem(rememberExpirationKey);
                }
            }

            async function handleDecryptOnLoad() {
                let isSuccessful = await decryptOnLoadFromUrl();

                if (!isSuccessful) {
                    isSuccessful = await decryptOnLoadFromRememberMe();
                }

                return { isSuccessful };
            }
            exports.handleDecryptOnLoad = handleDecryptOnLoad;

            /**
             * Clear storage if we are logging out
             *
             * @returns {boolean} - whether we logged out
             */
            function logoutIfNeeded() {
                const logoutKey = "staticrypt_logout";

                // handle logout through query param
                const queryParams = new URLSearchParams(window.location.search);
                if (queryParams.has(logoutKey)) {
                    clearLocalStorage();
                    return true;
                }

                // handle logout through URL fragment
                const hash = window.location.hash.substring(1);
                if (hash.includes(logoutKey)) {
                    clearLocalStorage();
                    return true;
                }

                return false;
            }

            /**
             * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
             * try to do it if needed.
             *
             * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
             */
            async function decryptOnLoadFromRememberMe() {
                const { rememberDurationInDays } = staticryptConfig;
                const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                // if we are login out, terminate
                if (logoutIfNeeded()) {
                    return false;
                }

                // if there is expiration configured, check if we're not beyond the expiration
                if (rememberDurationInDays && rememberDurationInDays > 0) {
                    const expiration = localStorage.getItem(rememberExpirationKey),
                        isExpired = expiration && new Date().getTime() > parseInt(expiration);

                    if (isExpired) {
                        clearLocalStorage();
                        return false;
                    }
                }

                const hashedPassword = localStorage.getItem(rememberPassphraseKey);

                if (hashedPassword) {
                    // try to decrypt
                    const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                    // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
                    // the user fill the password form again
                    if (!isDecryptionSuccessful) {
                        clearLocalStorage();
                        return false;
                    }

                    return true;
                }

                return false;
            }

            async function decryptOnLoadFromUrl() {
                const passwordKey = "staticrypt_pwd";
                const rememberMeKey = "remember_me";

                // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
                // since it sends the hashed password to the server which isn't needed)
                const queryParams = new URLSearchParams(window.location.search);
                const hashedPasswordQuery = queryParams.get(passwordKey);
                const rememberMeQuery = queryParams.get(rememberMeKey);

                const urlFragment = window.location.hash.substring(1);
                // get the password from the url fragment
                const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
                const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
                const rememberMeFragment = urlFragment.includes(rememberMeKey);

                const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
                const rememberMe = rememberMeFragment || rememberMeQuery;

                if (hashedPassword) {
                    return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
                }

                return false;
            }

            return exports;
        }
        exports.init = init;

        return exports;
    })());
    const templateError = "Incorrect Password!",
        templateToggleAltShow = "Show password",
        templateToggleAltHide = "Hide password",
        isRememberEnabled = false,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2bd83cc852f3f7119514bddd0853df438687e62ed4b029a89df6279e00bf7bea7d7dc656ae0addd55587c195468bc8f4ee42236f34ffe514e3b0c4f9e1f557aadc8928f8694938d79011b33f1af90b232a9c7d31e5d1a50f62b2c1907601e9b6f4b8c3f4cf774c3c588ce881afea6581ba5b710200afa161e40d73e542ba58143e28fd7e19e188ac9ce67fe26cdf9db23b879426da07a5b42a0565a9806be892b93c4b651e8d1cc9ac3dff689352f0203c7ea83382d6226505beae9ff17a3c254606f06b94fcc32616b6fe2f4740fbed466757a0efec8516b002332c4a9024a1907a4d63bc3a4071db451c6c2829e1cbbb717b1df66178ea0b7c2cf6270be17ad2e4a053e5252deb3c4b0fc1f7a0d36ec0cafc31218c7be2917c7a80dd7deed861b1686c33b738720658832771ec0340a3665e0fabdbace492f2318bfef3e815e3928d0586dc3e84d5e6eab28f4375e23025d1100eea581cb36bdc3df8a16a07cb8a1ec7ad9fd0e0b7a7277307ae5dfc457e1f6908db3ab76f6ee6cd243d5b8169acdfae5e5e987709c1cd35badc5ea8b1c6ba11d0c1eb337ab5834599478a71c6d202d34f3136465aaa402168542e777be653a0c5b338e14dba0e947a5ff8ff3fedadc640850a7c0f59ad26c39c29bf48fbac91ce2f6e4e3bf3a3e0dd9c0e97c2ac2b6ea1b39d6bf910f231b043d052fbc0a10a79d3a385b45270ad775bb5ca5d817f1027d4667d7370fac14fe31da2c543737444cf01f7d3517ca23b5c46bfcb016d29865ba75f56c102e5c68f8c07eabbdb3511c1cbfefb383184cbe66ca3aade13554c390468e78ae9a52c8c5881ee6c4e9a0bea2ea6cab04acd497e974f8f3d33e5e00796a798a2f4320e419fb5421496b16bcdc5857c93671e7cba41eefdf3ab6eba7521aa25faacb68ce16361075b1c4927555410fd2057c74cc2ad4d7fa357e3ff4a37e431d6b286ee73d7183ef902ac5d1c9e4a89ef934875aa9843308c0f6bf9d294750304a35f030c3eae08fe850e015fdc80780977ce63f4cd6432ca0fe83e3ca49bfcc18f59dc0467059535a163ab14baeaba31b86f98e6d753bb84b31d7b248504472a0dae42bc617c28317d28eefb716df781570f6f546ba6d61e322f48bdb2afa9c6a9ccf294a44c2674b00dbdeda5b8acae64fbe83f7daf58c9c041210dc0096783afdc3164640c480a65d24dff89cf5921b7506536fbe7f578f847bf092fcc4a19f5845958cbd18edadc92c5ac70d022b48335ba6721787a4bf99f2cc183dab4b1eb84eec0ed27def21ed2a2867c69e5c6c29676bcda5a44230064424884f45ddf6fbc0120208d0e328d72fc203f2cd5b3ebdccf3d90a104efa22094a106b20ee734e3e53738fb28899a39f4c8de8ad0064124d796eaa988b627c6e6dff8b7d8087e293d8a240e88ea00499c4657f6a1f3aa33b8b9693f42d9c19cae08fc9591f161084850af70dad25d6ec2895f187ed094305cb63d8c28d75c0376e8f33628069c6cadf869a8bb3347451d438fa01517459763639ac076e42d8eaa4891ff5c2473ba56636175c317f6b2181b31ce2a7851925160da89a15f3a74efcd930502004ebdf448c35efa9d4df9cdcadb0f5167fe1a89da78562ad5b0c23663a421a18bd4b046866e18fa3c214dc69807ff323bd21dd43347ff1bc916b292c656c4d9617acbf7d6e30acc77060d181d87ecc9b4f40878a80d00c6585c42373b2c01b68f2ef1b16cfce9cc3ee29ad65776747567ff551a30cba76d4e5b32e02608c25ed662a7f006245ac52a4343da4e3ccd83b9b1f398c1ff57b59eb99ee8edb2c3b56521988336203e9e47c549a671f690634ce5153b58ec0b5aed84d18ca1c48c6879ed6415abad6fe109feaaebe02051311c6c66cb36f99401409212fb20a1a3022ef4e0766f3f0f86654720fa6a2cb018b307c6e040b1ab595852c2289bf3a48760d247e86920e5a8aa8ef2306166322ad8a2ec03a43d7e3c812b7e8f7c87c424b0fff5170f8e78ca26464e9061928bfa39753a5086b39b9a6338bb40d8ed9809328ea5815bea825af68602354d57b67c55ac18594efee71799d63f428ecfa9d8363e216bde42899fc943e4ea5aa2bef7024f6d8727faa5377a792a67099a1ddaba9f6f95cf5e5278e78e40220c5d6f28e1e1109c546516cb71a7e8a92883387a25d553b0192127a748d6fdc42b5dfe83490f9f912b591070b69a16038bcfc42ba92bfc83852d91da87262b348a8d2c66758f4e26bf9065371f11e8133926f6bc1b4b7c85d9d27b08ec2f5231965061ab0443ea76646962e34fa7598ce3f3d9f0c7fa77fa397d4d4c3181e6f8216f7687c7f7fe5078182dd752743edc15ae13bdfd98fff7f6b518743f7111751e0ebffe8fcb020b33855a4c1e3a24d2fa3a470bc74b78c4953d3db3f42fc7617716d12f552a7aa00b78e6099ac0a8e5fcc43bb0d5fce2dd5fd180e6f1a0d6e09e1029a246db16e6f1d9e0a634db1e6abc3b9933d12563976461888f3ef69cd3f664969012d06e9a373e95be83d81be3065372663ca6ec064e6bf8f046fcd225a9dcf80531ac7143d9d96fbf6971d222ad030e3cd76680a2d97ea6d056f44fc261ce9dd7b0d5c9f28824f7d44ccc119fd9279d0c1765bf6bc3832a88544d91adec99cf027ab03ff0508b09c8fe053f161e7896617da0c876478d5e911d6b8da168ffd5c2c75af4250e9b1d63e8838fd8515abac6286ce5b4abed5d1e07cf2a4e15fb460d7c2b5f8b1f815abab02b41e35845b2841f8e7c3cb325c7321e68db86723afa7f23d13b9a285b80d4deaecd335f4c0608d587dfcab2b5d8773a5575ebbeec175037ef82cf6dfb308c0b275dd2d41fa8c56f2266e7ba9fc9acdd492194fea684a46f00f7950d2823427df3ebee5b34c0c27f205ae26518a2ae776904d53ec9d56a1a05f520cdc874722001bf9259b3cec03797ae875ac38f6a26c278b6fac605eb091418c6620d27785d73ed368cc510abd6fecce6d750bdd7107deb6f543ef19c996149e1bc15b933ab977f6643eb302e6e3ccb416f4bb2f352b5da9593d7ccfa7e851ffbdf05de8f54d27f330ff3a239f13dd5e8fcbbd8995ae7e56606d207cbd8aae7867425419675a166e7386dd7d1bbc22d25c319f9ccbdf9bc98358a428ea6166981b43ae6f18d8c81e78bba2144ee7aa6d1331d2a8ffb344813aeae40f079285d3b2eee4e62f6a091070a4ca83842af377df211f4d00f681e633dc75adae15a7de772247b2446f4a27d1243121a8a0885e19e193cdea98bfac1fde83ff9f58a492e4f60ca54527345a66ab44e1f0dd19acf5ac5750e1910b9b876c4a346b5baa0c0b37c2ad9c8d39667e0be17c714aa98e5808a75caa64297530a95d182730910e8d96bdff22195735a23b019b01822065a101c175b638c847b712678b8271633199cc7305e7d846fbe048ccbd87d83054dcaf9b1950f91d8a201adddb5ff39604307f3c44540e7e23f531e654642e68a04ea5854ea6626dc99d1b12cd735b8ba13cf1c8dafb276c55360158308cfa7dee27fa27e362db6a0b9073b6618a7977122e20f23ac5b778852955a70677edebfa9bf1ba0f7db7551c2cf21e3ffa49a39f0a876d2accb310f65e60de66ec415a39c5438d84da556b6609c4cf3015956728d2eb057414ef3bc99c9d32f1ca8e2c165e51f8134dd1ae04af9f63ea2ea8908dc3fb7728f14fbfb02cd1bc56648e02cbdeb87645ee802d90c85031e857c3ab2f24a7364ae6b27880de7f690772ed29c035a4986cb5e686ca0d1a495f024a97e581eb1ab6fb1ef1a20b98960a55b18ea074a800f2f15340d4aed5fc882abe7e13061a77b68a67dd22f4783cff7982a4cb905ad9c83486ff73ea9150b11731b83bbc2485b9804a017d949ffa2bbdfe545eb9d6f0639b7c6a92192d1a8dd0f9c0d09d68866a5ef0268b3da24f1cd5f840a4d5289d0e9e54451a0ce9dbd1a6a257d0a438f94cb8b1ad9b1c43b2d8cd69bb5f1c9a2b3ef2a6513b5637acb4523dc41e0e9595a528a9727256c874fbe2f93fdfec148e640277b0140605eed4a6a2e990bd478c4eced95be9da1e9d89e4c22f1a3e5eb37118c904fdc6e1b41cdf7528dfb0a6bfd5639d2bb8dea1616541cf273b87c5db99f1f1da0a294bc6a224f927baa0c598bde3c6dccb8b0a24b4de619423a18b6fb5cea0eebadd43be53e5f902181497fc458187c5be7a7d52671a87d8e73854dd2e7a54c327ad65fe3313bf6ec1818e2525276a00da30c26fd536c128c619df0a12ef0b8438e334a48fa5a6a53674e57c059a4b15272f0ff3bf96e238c6480eeb7d0e07dc93b346c8f483dbb7ec19d4a6cb9c8a2a127eb0be88398fd90c719ae24e5fe18feacb2684b38557b052b2dd880ce78a82fc857d53e611eb0b37c3ee3694c09507da8528a05683bc6096a40e0005f9c926a94acc7afd835b2662f136e666a6d61bcc451b6d6eff73f0492677a14a8d29febfdc895eaa61099b4f862be216ffca5e67ff96c1ea7944bd09222bed03e684b281cc7794d874a2c7f285884890f1df927e634829f2a98ab821722664d3dea0422c047c6e8571e071d48d86f819eba026a67463b898a64b484dde66259f1045f2961ca40fe0a9c441adca8f3cff96b765529750c4a39d5f9a09604156e3ab5d9759e08f368934c91bca022ac89b76fddb4684da6b5e1a6a744e5d3dbf0646bb6f9cf5892d8af032e949ed89d21ebddb86d6805a5c86fab46c753dc85f26bbaed62a91f261499b10fe481db927b54cc88554e41c4df370b72fddbff9da25437432e110b373f238992701d5bb04edce2059d4b11e2e196e551b838c51aa0b48518003af3419bd98192330e30edee5e396d8dfd1484a97105a0714f8e027cc6b9c5cd1a34e01c5e699b66900c36a484e4f239bb790addcef4454287ac3968d550979b18ab14ec255f0e527dcee83663090d8065f3007dec0f143de9f7e48d5278cf461b3ec903b96882f71eedcb4026a0f8029a2ed7fba4c3042598f4d7eb66ee5434a010fa2b0843a4d257bc41a4a30990a7b9c7e7a63707a59ce7962c4f57ebfd9f0d50a1f2cd3cd2b2f7d79d862d696c3fc1b396297a5ccee3f31467b51a679575c1933226df431f9c4b02532f8f920a615d688915219cb1e86a7757294acbf70929e17c5bcb5b10b92ee528351d8dceb185ebbe23882f1ac893902271ae4828b538e86224f7b8c8e126ed6f220a64cc4815803c00050e005e2a7e96e4ac97ea65192849846eaca5c008198c7733c6320ed6cfb404af32178cda03eacf36e127f79ede905c16df880ba7ecad990a5084128215d377f9caf395ec6c671b242f656f105fff41360082f1737ae02670e859dca52dc53a029a9d08346f68a3ba1a108fa69044ea7bdfdad379f7c2716255dd1c06c545167b9bc65e0093676794a6208dc3d7f9b85bed395e026a36afac58229b10e6bdbf4f01f5bfbfa2f10afdc7f0d750f5f6f698838c49a89931245b27ae5234653a60218ed163ddef0ccbba099fb2099012da0001b0a94a4892025cb6b70f6d5af6e228d7e6b28ed153704360d8151c4a47566153580771c4892f72c416bb049f739a837a57e6e15f311e7ee37de42a62d998a103e182560768f1e612eec93e7b2f3bae5f9f353ef4e6bba8408af63097b40e6ba1b3c8b507ce71bad3b694089a7d06e47bc933fcb792a68b773350f63186c806e03ebb0c6cbed4cc30c0922efdf049cc1156faea4e9b8219b712f8b0fdc62d1db4bc08ab72ef2a165b7ae2151047391c3cb061fa02dc8f391dd9f9262a8c16d4b7bfdb7b8f8ecaaa7534e72ff73fbca805d6e2c01b79ebbfa30cec87c951b555661d0ffe3c8b631aa76bb0300116d921b3cb53fcf836e82a9e63badb71d2bd7e01d8475326dd0460d4cb5d486b11e6b602e225056a0f99830dc493cead9e105da3705da5655c93c3f0d26e0fec0da52367c5cf7ccf2040fd88538cede39aedcec95f8dadb76096818b4013d981ba5f783aa8954491f772d1e2ee94eb700b53b81b7f8bf3fc99cfe7a6893b0cf668d1aad60cee3bc37ab2f9d3d3d1348df0d957d58335b37a9c1492889f271e0235e7c0342eac2932972c7497a5c3d276540c742ce6f7e52b889843366b17825ce5baad8aabec48f5a50773e5ab676d233c1f4b87d19ec3a336c1bb32640fd56bfdd1a1d3b9d4fb5f34909b6a5a4626e74f2435d21cf04dfe854bfa7195ad337097ef54b5b626a2518ceedcb7bd8f8d70f2b1c1503a3ca8fbba4905dfc7a408cf6eb2dd706aed87f16a67922820306b616319e9443344807eefcac7b273bdb536366e8d1e0012f674a4b3d0bfcc0a6a376d5bb17528b5d1706d579e5987a8b8d05c7bdc9a21ac824d21f81b9b27e91389099895ef6142b929bd0a6d6f3b02bee8bee3513a0b04247c19d2cbb6a2f735f5af8d7e8674b885753ada7ddcbd48aee6a06f870c5270213e42c5bec7093599ef4f1e83dffda341dbd17a48be72345da20f3b04dd0b9fe35ff99aa8d998a73fa48a42cced08c43e9fe0efb264fc29cfee5f5f51aa544c2d34a735f8bae95295623bec29d034838a8d281d5f4f9c97d2f20e9a0a945e6f55216399ab7b255a06dd7f0297944ad2cfe216cf39019c9165ad05ca025f858f9e6a52af809d56755e2a76f09ee2eee35b3c52b6c3f16a590ddc381e05dfa1dbbadefdafd92449150d6473e645e483ccac79864eed1ca89dfd3dd9795488fd0eece9e6b10455753fa7763489f7d1f32786f327125275929fde4c9bbd7bf3cea89c469325d32d9140e85f68e73e77da0693112941cd77ba21c2a0c2cd0f0609022413cc031b9adad058cd80049d9f3fde237bfc109e9d9d6b2239c44d5f36f44451be31774fc6da0147520ab7518e854a4a0fb536f164a8d4090cb110ce5f807d7b1671e37a70c5b19b89e8ace9221eb9f289a9e60bb8536c2b8a27fc63d74db54b02a5ef03418a9d60458b83549fa55187eb0e0ed3a1be607d2b4caee55ce6fb382cc0179916f23616ac3b936b3c8138d666cbc7ba2947a99bfe30b0fef1eec1e2eda79d72e93ee75deccd22c16d54ba2b70b04e426bea8d77930dfc9e125fbf4afb55c0c0d1c24f051c668afe9f590c78ba3f84bd43b147a0a522ddedf647f503e8223727afd328f7cffc36091ed639206c39a88e4b6742214a838c0b1e84edc5bf7a78daa1699594d5852b437e6cb73853553bb6e6f1ed2a718e41e41988d9436f3950c3ecac79008d3caaafffcffd0fce8206e580f1801ba583d8c6ee71da5480bc553053c845979974b4fd8488120cd510cc80a5d4c92db678a22a86a072cd623287fcf74975d81b435e10d783dadbc1ed37df48fd00e3eb682f8270a5881b8e187b3dcedb2f047a6e6b5bc2f60cd9909ec7a2b349a2f74cfc0e4017b6579670c26a026da69e1c9e016bf685f0535459dcc6bc9d80cf7f5fc96ff8f656cc1583f14780443b3a62a3da095688bd324561d13d9b895e5ee9a531a2517a68823d335e4be0783ca582c0aa1fe85efa5629bfab1ecb367e5ab6617d9ecb088730d11f2e37cb443d457eb86e96e30c17bc64821dd390f3abbd54f41cdc83e2fb1841415c9e989b941bda2deb9a9ea7d4a3cb81005c726fb594efc5b0a14786d0c8b5699e11348f55bc75a276dc76c6dc0631ee35000eb33a063a097058b4a8987fde8d2be00127e1e96d89800ab450e0f651e9ed0c9ec34c463ba8020bcb9d1da8542dc6bab739e6d9a644a9fe8b30388311483474216ebd86efc834b6b1d70eaf2d725a419167a7c0342f3cece109872a0c4a7655bc10f50ee30be782b5396c945ef9f133d66e9e77b2b7d28fad17f822d4785a85f9e78dea1d6f7e4f110213256d61efb3bbedfa99db71031ef9951579741c5bd41e5b981c4811eda35e6aec3e90a0f1c5169351778ab21a0b58364f5f69e1255e0e936847d5689217577f3197e99ff452d7721af6cad5e67d484bed1d0d6d721f6dae9ec3ea6bfc997ff20db4d813813c38f419acd5d9a0e8f64e1f5018f26deb2ed8c644247d934ebedf4b97a40d2b6747e620cda0c7005c919de368953b348a8cae58d88ee174897a660cda17ddc0d5868108a2dc8564c9bbd528adfde201720fa61f3cdece31cfb12f3ce08e2bdb33c070e3c0809345473437ab6b000337ff5770f156abdfc39435a4e44afc19fc1796d1f6cebc11892fbc7ddb0fb87e4eeb7bb59c6cc04b7eaa329aca3735b8bb1fbc88a0b10b7526c51b42c1113a4095750e1463e3f29bf7deb3984ca26a2180ab4d65f4afb9c302173096bc98608f001dcdf3a87f58fa1fdf92b0ee09fa3b3fd69b615ec9654cc5cd31aca960bf741938fd53080c2ce6b404bc07e5b9b1be30384a2207a1beecc206fd6c3255188f2bc2001720f465e9e248826eb7bb7e820a396cadb34f738fd3224d8b7a3e7cd5fc066ef16f1af37203bfd40a93a91d7cac1a8b29a365fbcabb8052674a5682971108abd0189828d02106a2991041df3861c30749d63b7c2c0e00ca13ce73e7aed0937ba9b1bb9bf9a3d3190288407ed7e7eb0a2950913b3cb09fb61e0aa588fca09a23892ad1ccb419e891630aa994001bfd2b467668a1902d5b4b82edad253334dd1e919218abfbdf35aa831f9b628f9811d088d5481a18d8f7fca349b54379cba5ad9fa3a08bfee293d2249830cdd09932d0536b66b232e1203c0bbd94cfe1acbfa0caed7caa1ef7e585c534ffdcfe5d041018866f1768cf9550b8ace0110824db63f2e32335f21380f61746e28ca154eb63696d092fe9e3fea39b2b67af2c8301c0559aa1e2e3514796e721a6519251ec9d2cccd24347aa92d53feda54f6b091d79203d7d7308b6f8079ec4751f99a19e","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"934c14950d2a7b4c7dfdf5b951d6ec20"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise, the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById("staticrypt-remember-label").classList.remove("hidden");
            }
        }
    };

    // toggle password visibility
    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    // these two icons are coming from FontAwesome
    const imgSrcEyeClosed = "/images/invisible.svg"
    // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
    const imgSrcEyeOpened = "/images/visible.svg"
    // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
    toggleIcon.addEventListener("click", function () {
        const passwordInput = document.getElementById("staticrypt-password");
        if (passwordInput.type === "password") {
            passwordInput.type = "text";
            toggleIcon.src = imgSrcEyeOpened;
            toggleIcon.alt = templateToggleAltHide;
            toggleIcon.title = templateToggleAltHide;
        } else {
            passwordInput.type = "password";
            toggleIcon.src = imgSrcEyeClosed;
            toggleIcon.alt = templateToggleAltShow;
            toggleIcon.title = templateToggleAltShow;
        }
    });

    // handle password form submission
    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
        e.preventDefault();

        const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
