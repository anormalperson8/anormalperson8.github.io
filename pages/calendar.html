<!DOCTYPE html>
<html lang="en" class="staticrypt-html">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/images/waving.png" />
    <title>Locked! | Sunny's Website</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #FFC000;
        }

        .staticrypt-page {
            max-width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            /*background: #000000;*/
            border: 2px solid #FFC000;
            color: #FFFFFF;
            width: 60%;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        @media (min-width: 768px) {
            .staticrypt-form {
                width: 80%;
                margin: 0 auto 100px;
                padding: 45px;
                font-size: large;
            }
        }

        .staticrypt-form input[type="password"],
        input[type="text"] {
            background: inherit;
            border: 0;
            box-sizing: border-box; /* This ensures padding is included in the total width */
            font-size: 14px;
            outline: 0;
            padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
            width: 100%;
        }

        .staticrypt-password-container {
            position: relative;
            outline: 0;
            background: /*#f2f2f2*/white;
            width: 100%;
            border: 2px solid #FFC000;
            margin: 0 0 15px;
            box-sizing: border-box;
            color: black;
        }

        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            height: 20px;
            opacity: 60%;
            padding-right: 5px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            /*background: #000000;*/
            width: 100%;
            border: #FFC000 solid 1px;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #FFC000;
            filter: brightness(92%);
        }

        .staticrypt-decrypt-button {
            transition: 0.3s ease-in-out;
        }

        .staticrypt-decrypt-button:hover {
            color: black;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
            /*background-color: black;*/
        }

        .staticrypt-content {
            height: calc(100% - 101px);
            margin-bottom: 0;
            /*background: !*#76B852*!#000000;*/
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        @media (min-width: 768px) {
            .staticrypt-content {
                height: calc(100% - 70px);
            }
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: small;
            margin-top: 10px;
            margin-bottom: -10px;
        }

        @media (min-width: 768px) {
            .staticrypt-title {
                font-size: larger;
                margin-top: 10px;
                margin-bottom: -10px;
            }
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .staticrypt-hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: calc(100% - 101px);
            display: flex;
            align-items: center;
            justify-content: center;
            /*background-color: black;*/
        }

        @media (min-width: 768px) {
            .staticrypt-spinner-container {
                height: calc(100% - 70px);
            }
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid #FFC000/*gray*/;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
    <!-- My own things -->
    <link href="/output.css" rel="stylesheet"/>
</head>

<body class="staticrypt-body bg-n-8">
<div>
    <div class="top-0 left-0 w-full border-b border-colour-7 lg:backdrop-blur-sm h-[101px] lg:h-[70px]">
        <div class="flex items-center px-5 lg:px-7.5 xl:px-10 max-lg:py-4">
            <a class="lg:block w-[60px] xl:ml-2" href="/index.html"><img src="/images/sunnylurking.png" alt="leftlurk"></a>
            <nav class="relative left-0 right-0 bottom-0 ml-auto lg:mx-auto">
                <div class="hidden lg:inline-flex relative flex-col items-center justify-center space-x-20 m-auto lg:flex-row">
                    <a href="/index.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Home</a>
                    <a href="/pages/aboutme.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">About Me</a>
                    <a href="/pages/projects.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Projects</a>
                    <a href="/pages/contacts.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Contacts</a>
                    <a href="/pages/blogs/menu.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Blog</a>
                    <a href="/pages/miscellaneous.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Misc.</a>
                </div>
                <div class="flex lg:hidden text-center">
                    <div class="absolute right-10 hidden w-60 border-colour-7 border-2 rounded-lg overflow-auto" id="navbarHamburger" style="z-index: 10">
                        <ul class="flex flex-col font-medium">
                            <li>
                                <a href="/index.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Home</a>
                            </li>
                            <li>
                                <a href="/pages/aboutme.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">About Me</a>
                            </li>
                            <li>
                                <a href="/pages/projects.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Projects</a>
                            </li>
                            <li>
                                <a href="/pages/contacts.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Contacts</a>
                            </li>
                            <li>
                                <a href="/pages/blogs/menu.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Blog</a>
                            </li>
                            <li>
                                <a href="/pages/miscellaneous.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Misc.</a>
                            </li>
                        </ul>
                    </div>
                    <button id="burg" class="button inline-flex items-center justify-center p-2 w-10 h-10 text-sm text-gray-500 rounded-lg focus:outline-none border-2 border-colour-7">
                        <span class="sr-only">Open main menu</span>
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 17 14">
                            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 1h15M1 7h15M1 13h15"/>
                        </svg>
                    </button>
                </div>
            </nav>
            <a class="hidden lg:block w-[60px] xl:mr-2" href="/index.html"><img src="/images/sunnylurkinginverted.png" alt="rightlurk"></a>
        </div>
    </div>
</div>

<script>
    const burgButtonTemplate = document.getElementById("burg");
    const burgMenuTemplate = document.getElementById("navbarHamburger")

    burgButtonTemplate.addEventListener("click", () => {
        burgMenuTemplate.classList.toggle("hidden");
    })
</script>
<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Locked!</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr" />

            <form id="staticrypt-form" action="#" method="post">
                <div class="staticrypt-password-container">
                    <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                    />

                    <img
                            class="staticrypt-toggle-password-visibility"
                            alt="Show password"
                            title="Show password"
                            src="../images/invisible.svg"
                    />
                    <!--                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="-->
                </div>

                <label id="staticrypt-remember-label" class="staticrypt-remember staticrypt-hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />
            </form>
        </div>
    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
        const exports = {};
        const cryptoEngine = ((function(){
            const exports = {};
            const { subtle } = crypto;

            const IV_BITS = 16 * 8;
            const HEX_BITS = 4;
            const ENCRYPTION_ALGO = "AES-CBC";

            /**
             * Translates between utf8 encoded hexadecimal strings
             * and Uint8Array bytes.
             */
            const HexEncoder = {
                /**
                 * hex string -> bytes
                 * @param {string} hexString
                 * @returns {Uint8Array}
                 */
                parse: function (hexString) {
                    if (hexString.length % 2 !== 0) throw "Invalid hexString";
                    const arrayBuffer = new Uint8Array(hexString.length / 2);

                    for (let i = 0; i < hexString.length; i += 2) {
                        const byteValue = parseInt(hexString.substring(i, i + 2), 16);
                        if (isNaN(byteValue)) {
                            throw "Invalid hexString";
                        }
                        arrayBuffer[i / 2] = byteValue;
                    }
                    return arrayBuffer;
                },

                /**
                 * bytes -> hex string
                 * @param {Uint8Array} bytes
                 * @returns {string}
                 */
                stringify: function (bytes) {
                    const hexBytes = [];

                    for (let i = 0; i < bytes.length; ++i) {
                        let byteString = bytes[i].toString(16);
                        if (byteString.length < 2) {
                            byteString = "0" + byteString;
                        }
                        hexBytes.push(byteString);
                    }
                    return hexBytes.join("");
                },
            };

            /**
             * Translates between utf8 strings and Uint8Array bytes.
             */
            const UTF8Encoder = {
                parse: function (str) {
                    return new TextEncoder().encode(str);
                },

                stringify: function (bytes) {
                    return new TextDecoder().decode(bytes);
                },
            };

            /**
             * Salt and encrypt a msg with a password.
             */
            async function encrypt(msg, hashedPassword) {
                // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
                // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
                const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

                const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

                const encrypted = await subtle.encrypt(
                    {
                        name: ENCRYPTION_ALGO,
                        iv: iv,
                    },
                    key,
                    UTF8Encoder.parse(msg)
                );

                // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
                return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
            }
            exports.encrypt = encrypt;

            /**
             * Decrypt a salted msg using a password.
             *
             * @param {string} encryptedMsg
             * @param {string} hashedPassword
             * @returns {Promise<string>}
             */
            async function decrypt(encryptedMsg, hashedPassword) {
                const ivLength = IV_BITS / HEX_BITS;
                const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
                const encrypted = encryptedMsg.substring(ivLength);

                const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

                const outBuffer = await subtle.decrypt(
                    {
                        name: ENCRYPTION_ALGO,
                        iv: iv,
                    },
                    key,
                    HexEncoder.parse(encrypted)
                );

                return UTF8Encoder.stringify(new Uint8Array(outBuffer));
            }
            exports.decrypt = decrypt;

            /**
             * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
             *
             * @param {string} password
             * @param {string} salt
             * @returns {Promise<string>}
             */
            async function hashPassword(password, salt) {
                // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
                // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
                let hashedPassword = await hashLegacyRound(password, salt);

                hashedPassword = await hashSecondRound(hashedPassword, salt);

                return hashThirdRound(hashedPassword, salt);
            }
            exports.hashPassword = hashPassword;

            /**
             * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
             * compatibility.
             *
             * @param {string} password
             * @param {string} salt
             * @returns {Promise<string>}
             */
            function hashLegacyRound(password, salt) {
                return pbkdf2(password, salt, 1000, "SHA-1");
            }
            exports.hashLegacyRound = hashLegacyRound;

            /**
             * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
             * remember-me/autodecrypt links, we need to support going from that to more iterations.
             *
             * @param hashedPassword
             * @param salt
             * @returns {Promise<string>}
             */
            function hashSecondRound(hashedPassword, salt) {
                return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
            }
            exports.hashSecondRound = hashSecondRound;

            /**
             * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
             * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
             *
             * @param hashedPassword
             * @param salt
             * @returns {Promise<string>}
             */
            function hashThirdRound(hashedPassword, salt) {
                return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
            }
            exports.hashThirdRound = hashThirdRound;

            /**
             * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
             *
             * @param {string} password
             * @param {string} salt
             * @param {int} iterations
             * @param {string} hashAlgorithm
             * @returns {Promise<string>}
             */
            async function pbkdf2(password, salt, iterations, hashAlgorithm) {
                const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

                const keyBytes = await subtle.deriveBits(
                    {
                        name: "PBKDF2",
                        hash: hashAlgorithm,
                        iterations,
                        salt: UTF8Encoder.parse(salt),
                    },
                    key,
                    256
                );

                return HexEncoder.stringify(new Uint8Array(keyBytes));
            }

            function generateRandomSalt() {
                const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

                return HexEncoder.stringify(new Uint8Array(bytes));
            }
            exports.generateRandomSalt = generateRandomSalt;

            async function signMessage(hashedPassword, message) {
                const key = await subtle.importKey(
                    "raw",
                    HexEncoder.parse(hashedPassword),
                    {
                        name: "HMAC",
                        hash: "SHA-256",
                    },
                    false,
                    ["sign"]
                );
                const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

                return HexEncoder.stringify(new Uint8Array(signature));
            }
            exports.signMessage = signMessage;

            function getRandomAlphanum() {
                const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

                let byteArray;
                let parsedInt;

                // Keep generating new random bytes until we get a value that falls
                // within a range that can be evenly divided by possibleCharacters.length
                do {
                    byteArray = crypto.getRandomValues(new Uint8Array(1));
                    // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
                    parsedInt = byteArray[0] & 0xff;
                } while (parsedInt >= 256 - (256 % possibleCharacters.length));

                // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
                const randomIndex = parsedInt % possibleCharacters.length;

                return possibleCharacters[randomIndex];
            }

            /**
             * Generate a random string of a given length.
             *
             * @param {int} length
             * @returns {string}
             */
            function generateRandomString(length) {
                let randomString = "";

                for (let i = 0; i < length; i++) {
                    randomString += getRandomAlphanum();
                }

                return randomString;
            }
            exports.generateRandomString = generateRandomString;

            return exports;
        })());
        const codec = ((function(){
            const exports = {};
            /**
             * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
             *
             * @param cryptoEngine - the engine to use for encryption / decryption
             */
            function init(cryptoEngine) {
                const exports = {};

                /**
                 * Top-level function for encoding a message.
                 * Includes password hashing, encryption, and signing.
                 *
                 * @param {string} msg
                 * @param {string} password
                 * @param {string} salt
                 *
                 * @returns {string} The encoded text
                 */
                async function encode(msg, password, salt) {
                    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

                    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                    // it in localStorage safely, we don't use the clear text password)
                    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                    return hmac + encrypted;
                }
                exports.encode = encode;

                /**
                 * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
                 * we don't need to hash the password multiple times.
                 *
                 * @param {string} msg
                 * @param {string} hashedPassword
                 *
                 * @returns {string} The encoded text
                 */
                async function encodeWithHashedPassword(msg, hashedPassword) {
                    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                    // it in localStorage safely, we don't use the clear text password)
                    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                    return hmac + encrypted;
                }
                exports.encodeWithHashedPassword = encodeWithHashedPassword;

                /**
                 * Top-level function for decoding a message.
                 * Includes signature check and decryption.
                 *
                 * @param {string} signedMsg
                 * @param {string} hashedPassword
                 * @param {string} salt
                 * @param {int} backwardCompatibleAttempt
                 * @param {string} originalPassword
                 *
                 * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
                 */
                async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
                    const encryptedHMAC = signedMsg.substring(0, 64);
                    const encryptedMsg = signedMsg.substring(64);
                    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

                    if (decryptedHMAC !== encryptedHMAC) {
                        // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
                        // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
                        originalPassword = originalPassword || hashedPassword;
                        if (backwardCompatibleAttempt === 0) {
                            const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                            return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                        }
                        if (backwardCompatibleAttempt === 1) {
                            let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                            updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                            return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                        }

                        return { success: false, message: "Signature mismatch" };
                    }

                    return {
                        success: true,
                        decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
                    };
                }
                exports.decode = decode;

                return exports;
            }
            exports.init = init;

            return exports;
        })());
        const decode = codec.init(cryptoEngine).decode;

        /**
         * Initialize the staticrypt module, that exposes functions callbable by the password_template.
         *
         * @param {{
         *  staticryptEncryptedMsgUniqueVariableName: string,
         *  isRememberEnabled: boolean,
         *  rememberDurationInDays: number,
         *  staticryptSaltUniqueVariableName: string,
         * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
         *
         * @param {{
         *  rememberExpirationKey: string,
         *  rememberPassphraseKey: string,
         *  replaceHtmlCallback: function,
         *  clearLocalStorageCallback: function,
         * }} templateConfig - object of data that can be configured by a custom password_template.
         */
        function init(staticryptConfig, templateConfig) {
            const exports = {};

            /**
             * Decrypt our encrypted page, replace the whole HTML.
             *
             * @param {string} hashedPassword
             * @returns {Promise<boolean>}
             */
            async function decryptAndReplaceHtml(hashedPassword) {
                const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
                const { replaceHtmlCallback } = templateConfig;

                const result = await decode(
                    staticryptEncryptedMsgUniqueVariableName,
                    hashedPassword,
                    staticryptSaltUniqueVariableName
                );
                if (!result.success) {
                    return false;
                }
                const plainHTML = result.decoded;

                // if the user configured a callback call it, otherwise just replace the whole HTML
                if (typeof replaceHtmlCallback === "function") {
                    replaceHtmlCallback(plainHTML);
                } else {
                    document.write(plainHTML);
                    document.close();
                }

                return true;
            }

            /**
             * Attempt to decrypt the page and replace the whole HTML.
             *
             * @param {string} password
             * @param {boolean} isRememberChecked
             *
             * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
             *   expose more information in the future we can do it without breaking the password_template
             */
            async function handleDecryptionOfPage(password, isRememberChecked) {
                const { staticryptSaltUniqueVariableName } = staticryptConfig;

                // decrypt and replace the whole page
                const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
                return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
            }
            exports.handleDecryptionOfPage = handleDecryptionOfPage;

            async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
                const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
                const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                if (!isDecryptionSuccessful) {
                    return {
                        isSuccessful: false,
                        hashedPassword,
                    };
                }

                // remember the hashedPassword and set its expiration if necessary
                if (isRememberEnabled && isRememberChecked) {
                    window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

                    // set the expiration if the duration isn't 0 (meaning no expiration)
                    if (rememberDurationInDays > 0) {
                        window.localStorage.setItem(
                            rememberExpirationKey,
                            (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                        );
                    }
                }

                return {
                    isSuccessful: true,
                    hashedPassword,
                };
            }
            exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

            /**
             * Clear localstorage from staticrypt related values
             */
            function clearLocalStorage() {
                const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                if (typeof clearLocalStorageCallback === "function") {
                    clearLocalStorageCallback();
                } else {
                    localStorage.removeItem(rememberPassphraseKey);
                    localStorage.removeItem(rememberExpirationKey);
                }
            }

            async function handleDecryptOnLoad() {
                let isSuccessful = await decryptOnLoadFromUrl();

                if (!isSuccessful) {
                    isSuccessful = await decryptOnLoadFromRememberMe();
                }

                return { isSuccessful };
            }
            exports.handleDecryptOnLoad = handleDecryptOnLoad;

            /**
             * Clear storage if we are logging out
             *
             * @returns {boolean} - whether we logged out
             */
            function logoutIfNeeded() {
                const logoutKey = "staticrypt_logout";

                // handle logout through query param
                const queryParams = new URLSearchParams(window.location.search);
                if (queryParams.has(logoutKey)) {
                    clearLocalStorage();
                    return true;
                }

                // handle logout through URL fragment
                const hash = window.location.hash.substring(1);
                if (hash.includes(logoutKey)) {
                    clearLocalStorage();
                    return true;
                }

                return false;
            }

            /**
             * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
             * try to do it if needed.
             *
             * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
             */
            async function decryptOnLoadFromRememberMe() {
                const { rememberDurationInDays } = staticryptConfig;
                const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                // if we are login out, terminate
                if (logoutIfNeeded()) {
                    return false;
                }

                // if there is expiration configured, check if we're not beyond the expiration
                if (rememberDurationInDays && rememberDurationInDays > 0) {
                    const expiration = localStorage.getItem(rememberExpirationKey),
                        isExpired = expiration && new Date().getTime() > parseInt(expiration);

                    if (isExpired) {
                        clearLocalStorage();
                        return false;
                    }
                }

                const hashedPassword = localStorage.getItem(rememberPassphraseKey);

                if (hashedPassword) {
                    // try to decrypt
                    const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                    // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
                    // the user fill the password form again
                    if (!isDecryptionSuccessful) {
                        clearLocalStorage();
                        return false;
                    }

                    return true;
                }

                return false;
            }

            async function decryptOnLoadFromUrl() {
                const passwordKey = "staticrypt_pwd";
                const rememberMeKey = "remember_me";

                // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
                // since it sends the hashed password to the server which isn't needed)
                const queryParams = new URLSearchParams(window.location.search);
                const hashedPasswordQuery = queryParams.get(passwordKey);
                const rememberMeQuery = queryParams.get(rememberMeKey);

                const urlFragment = window.location.hash.substring(1);
                // get the password from the url fragment
                const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
                const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
                const rememberMeFragment = urlFragment.includes(rememberMeKey);

                const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
                const rememberMe = rememberMeFragment || rememberMeQuery;

                if (hashedPassword) {
                    return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
                }

                return false;
            }

            return exports;
        }
        exports.init = init;

        return exports;
    })());
    const templateError = "Incorrect Password!",
        templateToggleAltShow = "Show password",
        templateToggleAltHide = "Hide password",
        isRememberEnabled = false,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2446870e5370afbe9c7318760ced027dd602c9a23d5ffadd37ac09303050f3206a43bd36cd5f5a5ab16d02eabc181c7e20b23f6ccbdaf5ab60e9d236421575c9ab4892c682e1562c2fc81c9fc0c79d84b92d4baccddea97707aef72ee82413793deab7526de9860445afc6a83091f5c76db52240b713f4ebcb603d00db1764ffdaef04224448f21f6bcfd7f8cec751081d87489ad0fcd5529d341c6dc7a17f5ad0c157749b17ffd62a1b03fb6d04041f279e92a2586e729cdd0367ac559a86959a2c295cd6f9d953347e1077dc1d475d46f1a60bf17c87c5031e1a5e325433839fbe8a5af4fc368e5560fff439260ee4b3ca30a8a60baec962bfbf19b10c92ab33436962daff1034b7c999c03659b50bb2e7b89437f99b39e254d5c30fd1209f4c26e8a014d623b79324114cbcc316503b22e5879b0fae2bd96845652bf39c63028edfe567dd5355ae39e0340e1b8c8f6cb20301cd0e2bde7d972dad344c24de310c58da8e3181bd0624a13a954b976789b6ddb257246f156183e58c8eb9fcc01963f2688d4f42ec2377926e1aaf358e0d58ad22c087c49cd0445f604fd2a905403208ac87eb243d7b8f52346ec8f9b21c5c5b47259f046c619995c261d6cec20249ac89d186677174f88350f18d7970d69438c2f2edaccd6824289e0786e46b6a0900ad1a29e2a9ac255b441bcf284e262ef495aa4981ef76b3ecb9b68a302185bcc8832cb8beec646c58f1d03666f5c7c75d3339f5b8a2e8b1514d4417df7b48a52dba6b698486b56b120c471bb16ccac4dddfea3bc5280afc419eb37de7260e3da1afb9347b55cd247f94c113653b63cbb9fb7542bf61bf3cc9913e0c8cbdd00bd4d157f8465675f5e5f3350e2d6e30fa999ec5aa4873a6e7eaf7bae22070d3f2c6f14691aac8b171cd61f5f43cc96434f8e5bfe934e31f4d3b01f2df6c6bd191739b8b2f946547b6ed58771c2a5242ce3b2859921b826a9e775801accfc67f6deec5b4cb207ffe2f0b351aa41d7d201ce98be2888711148516b431f520974f6f925ffdeb8009ade2a3fe03f60054e35955af09414189110fac4629fb486c7940a2ee751444258086e563e0199ba6a439b4174f40b8c4677fe908bd19401c1d78503bab7e45bfd851e0abe53e90137fbf100b0ff1e5004700a0d766bbaee00d1e2ed09be5e1801a162e7ef6114510cd5474637564766f1256676660c4d3c1cb1122dd04955c1eee5901bc07d80e414877b39081a15dc02f2e673da6371c58f14e3da1022d723d165246909055e74d5d1a18676a9c9a570bbff0a6cfe4194003d920e1499e7b798f20126301c00d4e444e4262674bfc48a5e23448e4253e8a370a7eb010b7339dba7cfddf7c2d2725b516ba597f2a6b147f947fde231408cff5c305a3fc2bdf6b2193eb54c4bc1595409c3146ace194d660b1e1e82a1d0e8ec2b778a41ffaa4ebfa7544f70bb5f1b59d5df6cfd58315b730378ff8359a59905632692cff928b10e383205f9e89c70b7cf78aff2685cab166cc844e6f9a8ec018fd5f0343c0c28b2eec18e07d5064ce9816e9b107726efbce2171549402bb4050fa4427d68c51ba95baf3c9ae2389d2e681de42ec369788cf36cbaa880e07bb3c89a67ebbd2c8b1b1feafa236671fe5ca1007b72c53797e81af40455039c84960a392d6c559d4252b0e332330d3ba6ea52f90dbc34a64ac778182e7ff2305383f622180cd4205180b4cb81585cf756dbb7058035e8f9d430551593132ed066f8eb46da0601728b513857d2b8f748992e515ab4d02a90151e4f792d712ef680f3250571cbff278448ddd1690464d101cd7ecea6d573ea03f5d79fb5955c26ac1e986e193f92da021410e16fb90032c90cd623b235f6d939c1eb2aaf9e84392ba08060eeab5d6475038683b0d6e6b5e481c1eb22cf54d3fd5328b41c173cd62db3b4f749acf394d7231ca617317d3e1ad6a4bb0efecf34920b78a3aa958ac4cddd92f00a47e6750504034da59dc32c4c06ad4bd2b91f04f21a15967f7bbd1a839c97e2bc1224b64fd095ad391df828e767120f33761dc107f68ce2e7dab5f9bbd2656eb849e8a563c3068d1d0b344437569565a9a99629c3b26ea5bd53f360d1e5ee09a7c9111906b54f978b184de3a83ad7b2c0e297553501be6d69cb62b1df6901d863415e454c2b065755076d5dbff9fab15c00389a516c16d6d2a95fe1b733ed8484f69cf441f7ba7d748e945b887a7c80c42f81590c028742397515b49b1b49ddf8c190fb2c1dc39eca3d9945f7faee1c0a2e0ade17ec5d8a2598e5e68defb9c83587c890c8b41f7bdc1ed535d379bd07b01a8fc7cbdaf0d8ec9d747f42d85149dd9ad369646b5cb7412e8637834f9aaee79c281801dcd19fb8e0d5e3a7c2dc5cbaa4485044fb4caa8528c065b501f9a3ea335deff9b023c8651b4afa55ade3e7c4d81ded87eed622f47632079a205100951adc60dd9267a92a1bc392cba362e0a5a93d7ced747d7a56e3f0b78397cd452f9ff7e444fd7c71e5b23d9846da4f43a2951fbe26e07bea7b355a0b8ddad523a14a72fb71698faea2467c1275fa4aa5dffa8da92813377b96552d4bcea81382b2ffd09f071bcc3ee914402b45ae7cb9d3f11f48f7f4f73baca6e2cdcec0e1cff0b3b06bb0d72528766a4e3715fa3037f0e3710e037aab9e98bc5853f592800154df81a59c4e46c1e2623222880867fb5e7edfb963e600c8e8c73c813cf04af5b7c9e41586e4779cfeb337de950fd49a19f3a27d7369d9dca943d22951eb1ac2cd67b1012ca20a099ee1b4b1f06f31472cafe99dd74a9e17f4c8d4e62fa81d4dab6c7dff4f06b983c178f29238e8d4333ebd37dc2c518d3e011238ee7bf713544997f8864cd4d1180d8aad92d581ffa2d09ce895e6d387ba2587dda3765c2261c5859414bf23b53c3b74601128b9ac10fa3a28bd134f76392b0de58ad4538874871fa003ef70b63d8bc2ea25e26c918f100f489fdfc3185cacb35c45b24bbd9f18eddf5b445685db2101cc4640bc71f5530c3be06b5809ff763a10d7c158bfcab21cc73d9ea5e3c36db4abb40ba54859606c772846bbcfafe62bd6484f9d7e1ccb6b02941eaa7d96e8055e8738c2ef564a938dc111f99e054f9ac0874a45b5fbc144620b515fa162490134cec8c57420c2033857fcff6e2ac7221ccbf5b2114dfb2e76f386737ae5f1c7b36f7aa5c1fca5442d8585d26e9361c77d768b85dacb11fd180dd204c1dd17f397e82252c06cd2bcb5575918141b6e9c3fcc3c3cb0795779ee3c8edce31c0bd1467a35e6e732041c5324cc09d9ff5811a6ccd15cd6c3240512c6a5b1cd324f5a95e15bbcd1c630faaaaaf33e3c8f29a3f7fb950a6435981cc43902584a636d69584a46136aa2563cec3f215a3796b9221d9fb7b8e8be6227f21c879609dedddc9305d15ceda65f977cd57abe6f99abf744e8c9621d777e3f947200f43b9892f4565ec90b96cb01297cf52b9b820e9592655755c873fd7180e3696f73af6de5f2f72dc5011c639d828ecdd86dd4a9434456fce56290155e5cc19a9913d5e77e2b513d54666c52e061d45f8447910a4939fe7ffb9942219cf452e4c75e78fc762118edeebc288f6dcece8780637fc4a303360bd01fda33f31ce21185149e1b691c78ce0872c264d1baf5ef476f493051ee661a9eef9b5849fe595cfb18d3961aae43d1e845b0b2eb4d61221755dc376fd2f1e64ea8ca517e69fc88a787207248b98e22122daa334704d6e17ccf6a61f365e6bfcac37aaf2ce9c9843aad44f54d6c383034d5ae1ce1ae96cf486ecebdcadd9fc317544e184ecb2dbce1e655c4a746eda7eefe27b70175c52defefabc35a1cb55af851b7fee8f4aa83826e5f02d1d278cba8d94048d3e350fbae31ecae2159eb80ada34b7330d49ac883b05338461674e44c39bf5732c5c3b8a568e1b23bee9911eb8b40e89c28ebed453bf3be441e83d421c4f199a63886287058e3fb0438a92f15558df681f950a943db1e8cd58b3ef83ed01e6ab2c0349a6eec46111c20eec72e44b040f4ef040db05496ec6e52316999d46685c3fe576edb32a9a8df918f7c0d55b5f0dd9c4f261c7d7cff7311eb159e5a3cebdf892054bc7bc8e539f824afaad32d1759ee4612382c9cfe4243ad4c162f47b54192a5f81f9a9b0792fe6e5d7080355534d6567f8b5a8ee6fc156c1e2ada6fda9040af1d74ecc3a2c24e1f633d0b0e9d3f7e02d4d44684fe04a178c2c7e202e3d719dd5a8f1c3e10b62b4d30616f31dcf0d76732342bf5f1fa3e063fe6f05fa5dd43668e9f48be9513bd9c24f45603e60391025c7b1a418fa78a9409dad88d4e5d6f87c7febeb7711b8f6bf0381cdfbda8d07586be783b7f6b10fa56854369966e91f2abb4efc1ef1b0ac26ea9d1d3623bb567484afe525f0ce5dc8b16149d1f35ef49ac9b000089034136a89711d1526f8d82f7f310f0e991470eeda2ce4ae4413157d2879cfbe4c2a0dc1227fde669ee6991227aa7fc638f75ba038d40a2f7bf6186de4de7fb16ba29c3c41b4578c4d1b2ec28cbe000d77f2be891d324b6f689701810a1499ccecb062889364aa2424f98ad30d4fe157d873a24e40fa2ace7a1c9ef7f23356ba4d8814098121915c6774215e303ac42d31f78eaee091724ade760b9f352c75640b528effc98cb43b5a275e2a46abe082ff73a85ec21df83fb515bb5aa23480f964dd348480ab777f6e0c6488a8895c26224336a58f99d6c491c713e74714c68bcf7e45ca28a93d660926ba17834f55bcd9b985807b6a77bd006e5766788f7f86aa6cce536efd4346f06d5066f77bdfded8ad1135064b2759a366b750786e14da27c6216df3bf1f756623a7bdb9be621635cc7c6f25550c922ba8c11e9adab64689b9f29c6b59e7baa04b0dfc94bb8970d1714b6e7ddbefc4dde05374e5e8497422fdc2bf0ef1313e0a7d00aef2c326c2b97b895efec54bbf353c65c404108d9aebac7707818b710624d737cdad1a3907545075fb3d7456b1bc30b28c350c5be67d5562f15ebb4b05b0c95547a798207dd5cfe42690ab457b0318c72373abfa1d56201c06f1965a523a78132b516e1059070830578682bb9303ad2ce58b5f34b581aaa81e17f6b83c1bd15355f5534bcc840113433bb79cb8d039d6f8ea8bde080018f04b4cd92af851ea3ac04ddc29c10e7d1cf2efe41f14564893659eb7753b9169f46c8a4492f6128750d56135015676248f5a0327d926a27e942e59100d50b6a33ec643aec4b16a29bcf4bcb0dcdf1cca3156c7451393f4883c39bc272b2939bee2759bbbc0ea2451b7304c58fd3ba99a1abd220fb46213fd2b1ff8bb1536a757c8bf3d84da8923fa5e1c2a2003bea0aed53afa5cd8120966903ad2ff4975d552a6caea068c45f046b59da1e4fc43ba6a62cca47cdf8b4e2b74782284cbe5bb33f61b614738f03a3008f8a8a6b5cdb30985d25ca8fe6e0af78b14a8408536ca2f80919f7b0dcb5ec748157c4019eb0e376904d09763794617536d91f32339fdb5770ce8796be9f0ca1c20284c6133deb4b8847b27809b0acd0f10dcedaeb11c992962a87440ba4ceec553109c053e0374dfd81719bf58e0a0074f568d4e2a58bd616b5a6e442d2168b6c0d6e82c00fb42d964a872051bb5500bc527b9c0e065c7e4190ce1ccda6752002553756569c5ade07ac78cb76b7a65ca9b87817762aa88878253a37ec81325acc98e61905edfb806d1488b75e47c826a294f10a44972ff3a00085a66311411b0b0909107dbf4f8ddab4759c8f12f2ee38b7fac050db1b13a718fb92f50c44899cad48922a7c39b89a238002a7ab5c99619bcf139d66cd2eaceae9d332bf8e4c857e50aa3faf10f54f9daada016b029eca04ab128cf85516693202b328cbefd84597f1a5a211d9cb0bd62f29db69f7b6fbc61881c4a82b00ec0b63ea04d79c16b80793b3eb31697f454613754ec5f030eda8494132ad4eb36858efeffe7b1627e1097e63da1c1a5780c8025d6021858bcea6f571dea00cbd37aa01baa0c97fc413678d3539c10f298b3ad321ea6332f293c69f380c585307ad088b8882f8a2f0d0af1c331dfb48ca39f6104f75ef9895bfe5c46a8517f2c1bceb10bcea9d61bdc4c1dc747c312bf842bb65044452306a4eb1f2272ee8fd947dbc9b90efb4349fba9e939c2fc4aab7a668f594b857b4738e10acd7082a467f0092308e978c7bc844ea4477863ad7a7382705386bbe4f629a768a36eb0da418a011130ff83a05b49acfb14abd3789aff9636afa6f64552625b3f5b3b83df94ceb9a2b914e6e96768937aad5d69b0b1926e857dab2aab4d48ae6015c3e7f0affaed60a9baa8b27e184e1e4ef6517dbb53d900d10d321f0a74baab76b77ad6183dfed6efd632fe6f860c2681724f2a5611b14fdb81cd123649149d72aa4021ff22a3d65c48bb70c1f8354e4e9c45625e0dc0bab682fff61d1f2bfc9285e24d32a5aa132f926f9e7a48cee638d7296d1557b482518df0eb77a6399440b411729f1617446554a8bde7fdc0c0a341ce63c15020d1168aa578120648f5a83877f8fb56e4fead60fe1ef0722aaf72621499a3520582d7e406a4c1e637f788a75166dfc218a3d6bc8baa3e8b312c9099ef640c708a186c7eb5b7b3f4add956b77838e90fb968cc72785e22be913456fd44e5fdde38c9ed37cfc26f52d67ee6653ed51e83897153daadd8e07b2d1888aba5512f86710fe021183de60e54002df1ed0654d5483f46aca9e6eb2130bf120a402894a02bdd9689a5d4ef070cf3574407f38ff97c14f48dcb487ee442794f105281bd4800973f3b241b471e6febeb3a8913bb77c21752253c44c293c66a51c4459115440bfb72f1b55c76cd9fbfc4648abba2358e84274c26831d5cfdeb7c77138e8289e47289da4ebbf6b5bc1c47f2a702d1fe052ab218dab00426ae4bb340148d6ce4a165738e27f4337829e1ac57579f3bb0b2ca7f920b0ad9930e681b9e0d44c8967b2c4bfd61c86069c5657c61bb9dd081890f4116cf839d9eeb8f6e84bf6ad3ce8e7e2a52c54a9d07355f12ecd51b6be95e95ec87f1d046ee04f4367c71d72649a3804fdcf0c72bf5509739e96e34020dca45250d10a41975a82343bf9d04526dd29d749d00e962e2c47495684954ea67d98591cf4877004fc0d7be1f14c1ce85298aa4351d902170f8218fd81c057c39efabef290fea1fa59840f908d7b4a1f1dfa98684c1fc3dba8c1aea490e905bc2c3cddcf5e4e95f3539c223fd124d2cdf6c0b2fe25ce69dfbb43b049cb3b6f58e79bdcca9d654392c943896a4e095f722fdb57e1ad122cad1c7905a3163de085d356c8c9e389e70f052ae9d3621471dc07b9a43e10311ba4baedcd50fd00a8d5119c7d18f933029dd2fba760dc4b590794c36131e8b4e9453eb4dc319e3eff54807c363dabba97b92386b2194329943971933469a1ae6cea9781dd973c36ac74869d3ce31fe6e64f0cd7e2316329a92eea81ac679c5df2bdc438087c7e009dc19def5909ea7e6345c87fbaf2d9876018db0a00bb7ef2ca7da5e6bfcf2f65060431356cd8ed6cbe32135cfc9e81c8f60345a4506abf4ebcda86435fd4dbeccd15ba3626003d0f93e2a8c6343d5ce24df3e3b6bffac73e9eff33b9d6706159972846faf35e54214e56a56b343100684a994c7692c803f92f0900097ed6e83240634943c1f6e316bff6453e9b90d7fe7cab60fa6da68d32d4f84056d3927ee1266de639bb0f28ecc8ce6feaa8ac18ebc5219cc823125bc1aa75da60b23c63366ac36c8f9d9ce1bbc83cda05580d27627fb790fcc017e972a0dd0a95f8cf9960ee677ecc7362d5ef67c3593d6a73b36fc58ff174b576720f177a992f5ddc042ed07ef21be537b5fa78b2f9d98c98c6842883a3d7d1d4a89d84ed7ab19846c11cd9531712d6fa4245e20e6ff9c6f3411f5bbbec6f3e2c5a451690cf128fc515ef1ac5a9271f9400c92afb53d0acd4f7c1558d67e1a1ebec9c75260c61f8c1e154ec43fd87f12c3a7a95a47395cf8b6889fb7506ba5264f9a63b0a0033e96027057af5f7a53227b14555fe76272d326e4befa43fb50421e8105ffb1a4122759ed1fe327873379a99c6d0906c333a3d2a17c9772d3a283f77c7c44ac146fe196927c14ae29a62191180889bd3c8d1eb08b2e1a4df4f18d5d6d7e17780c896282d118dc3bff4ee9b02a2785f833bf76edc31ce29c5bc36c79d70d077ed3c080ea7a6b8cb8f035c2809d254d478b9de891d9cffeb2a783d2fea2bddb769d866d651e4913966af20384bad4654f49fd1588301200ce819ce0a165e5f4ff2798f25fecae7037769225f2dfea05eeaff3458c284bf474e7833ee0c271596a4cde40f1c23320936dbc533517eda7f3e55603bb29ab39c53e403c629af9d59324059438b766ae9ebeef6533a9bea6855fa6a186041ed2ae25ced6fc0399559f05b5efc2707d653cb0b6e6ae721517e937bb90a16c5cbb6252fff7245cbd80cf9b1630364094aac3d5ed9cfa08338ffbebfa11af5bb5a027986206ae1eca574534659b63a0abb473f76c8f6bbc76f3b58a8d3455882dd5c6212bdac2c565a7703eddf14315453535e31dfbf3ebf6d37b520f52d7feaa07b43f1c5789a69b427a7ef9a346c27e701924cfdc4ea69ad3a902d05c1f66b1e5c5e5d524fce699ba2641bf4063a4b6fc4c960a48b3bc45ba1819756ed9a47814364ed619995795e8a2a655e3a975c6d7daf9d35d28685c230b3733f3878afe6c50a5e391c8815c24ccdc2183472e0ff820475ce9cdb8799d55418ed5f6c74b1799caa34507bd2ccf0402f039f951c05a9d38635ff1ead6b7ab86ec167ff02a23bec0726a","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"934c14950d2a7b4c7dfdf5b951d6ec20"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise, the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById("staticrypt-remember-label").classList.remove("hidden");
            }
        }
    };

    // toggle password visibility
    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    // these two icons are coming from FontAwesome
    const imgSrcEyeClosed = "/images/invisible.svg"
    // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
    const imgSrcEyeOpened = "/images/visible.svg"
    // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
    toggleIcon.addEventListener("click", function () {
        const passwordInput = document.getElementById("staticrypt-password");
        if (passwordInput.type === "password") {
            passwordInput.type = "text";
            toggleIcon.src = imgSrcEyeOpened;
            toggleIcon.alt = templateToggleAltHide;
            toggleIcon.title = templateToggleAltHide;
        } else {
            passwordInput.type = "password";
            toggleIcon.src = imgSrcEyeClosed;
            toggleIcon.alt = templateToggleAltShow;
            toggleIcon.title = templateToggleAltShow;
        }
    });

    // handle password form submission
    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
        e.preventDefault();

        const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
