<!DOCTYPE html>
<html lang="en" class="staticrypt-html">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/images/waving.png" />
    <title>Locked! | Sunny's Website</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #FFC000;
        }

        .staticrypt-page {
            max-width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            /*background: #000000;*/
            border: 2px solid #FFC000;
            color: #FFFFFF;
            width: 60%;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        @media (min-width: 768px) {
            .staticrypt-form {
                width: 80%;
                margin: 0 auto 100px;
                padding: 45px;
                font-size: large;
            }
        }

        .staticrypt-form input[type="password"],
        input[type="text"] {
            background: inherit;
            border: 0;
            box-sizing: border-box; /* This ensures padding is included in the total width */
            font-size: 14px;
            outline: 0;
            padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
            width: 100%;
        }

        .staticrypt-password-container {
            position: relative;
            outline: 0;
            background: /*#f2f2f2*/white;
            width: 100%;
            border: 2px solid #FFC000;
            margin: 0 0 15px;
            box-sizing: border-box;
            color: black;
        }

        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            height: 20px;
            opacity: 60%;
            padding-right: 5px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            /*background: #000000;*/
            width: 100%;
            border: #FFC000 solid 1px;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #FFC000;
            filter: brightness(92%);
        }

        .staticrypt-decrypt-button {
            transition: 0.3s ease-in-out;
        }

        .staticrypt-decrypt-button:hover {
            color: black;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
            /*background-color: black;*/
        }

        .staticrypt-content {
            height: calc(100% - 101px);
            margin-bottom: 0;
            /*background: !*#76B852*!#000000;*/
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        @media (min-width: 768px) {
            .staticrypt-content {
                height: calc(100% - 70px);
            }
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: small;
            margin-top: 10px;
            margin-bottom: -10px;
        }

        @media (min-width: 768px) {
            .staticrypt-title {
                font-size: larger;
                margin-top: 10px;
                margin-bottom: -10px;
            }
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .staticrypt-hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: calc(100% - 101px);
            display: flex;
            align-items: center;
            justify-content: center;
            /*background-color: black;*/
        }

        @media (min-width: 768px) {
            .staticrypt-spinner-container {
                height: calc(100% - 70px);
            }
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid #FFC000/*gray*/;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
    <!-- My own things -->
    <link href="/output.css" rel="stylesheet"/>
</head>

<body class="staticrypt-body bg-n-8">
<div>
    <div class="top-0 left-0 w-full border-b border-colour-7 lg:backdrop-blur-sm h-[101px] lg:h-[70px]">
        <div class="flex items-center px-5 lg:px-7.5 xl:px-10 max-lg:py-4">
            <a class="lg:block w-[60px] xl:ml-2" href="/index.html"><img src="/images/sunnylurking.png" alt="leftlurk"></a>
            <nav class="relative left-0 right-0 bottom-0 ml-auto lg:mx-auto">
                <div class="hidden lg:inline-flex relative flex-col items-center justify-center space-x-20 m-auto lg:flex-row">
                    <a href="/index.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Home</a>
                    <a href="/pages/aboutme.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">About Me</a>
                    <a href="/pages/projects.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Projects</a>
                    <a href="/pages/contacts.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Contacts</a>
                    <a href="/pages/blogs/menu.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Blog</a>
                    <a href="/pages/miscellaneous.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Misc.</a>
                </div>
                <div class="flex lg:hidden text-center">
                    <div class="absolute right-10 hidden w-60 border-colour-7 border-2 rounded-lg overflow-auto" id="navbarHamburger" style="z-index: 10">
                        <ul class="flex flex-col font-medium">
                            <li>
                                <a href="/index.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Home</a>
                            </li>
                            <li>
                                <a href="/pages/aboutme.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">About Me</a>
                            </li>
                            <li>
                                <a href="/pages/projects.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Projects</a>
                            </li>
                            <li>
                                <a href="/pages/contacts.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Contacts</a>
                            </li>
                            <li>
                                <a href="/pages/blogs/menu.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Blog</a>
                            </li>
                            <li>
                                <a href="/pages/miscellaneous.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Misc.</a>
                            </li>
                        </ul>
                    </div>
                    <button id="burg" class="button inline-flex items-center justify-center p-2 w-10 h-10 text-sm text-gray-500 rounded-lg focus:outline-none border-2 border-colour-7">
                        <span class="sr-only">Open main menu</span>
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 17 14">
                            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 1h15M1 7h15M1 13h15"/>
                        </svg>
                    </button>
                </div>
            </nav>
            <a class="hidden lg:block w-[60px] xl:mr-2" href="/index.html"><img src="/images/sunnylurkinginverted.png" alt="rightlurk"></a>
        </div>
    </div>
</div>

<script>
    const burgButtonTemplate = document.getElementById("burg");
    const burgMenuTemplate = document.getElementById("navbarHamburger")

    burgButtonTemplate.addEventListener("click", () => {
        burgMenuTemplate.classList.toggle("hidden");
    })
</script>
<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Locked!</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr" />

            <form id="staticrypt-form" action="#" method="post">
                <div class="staticrypt-password-container">
                    <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                    />

                    <img
                            class="staticrypt-toggle-password-visibility"
                            alt="Show password"
                            title="Show password"
                            src="../images/invisible.svg"
                    />
                    <!--                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="-->
                </div>

                <label id="staticrypt-remember-label" class="staticrypt-remember staticrypt-hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />
            </form>
        </div>
    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
        const exports = {};
        const cryptoEngine = ((function(){
            const exports = {};
            const { subtle } = crypto;

            const IV_BITS = 16 * 8;
            const HEX_BITS = 4;
            const ENCRYPTION_ALGO = "AES-CBC";

            /**
             * Translates between utf8 encoded hexadecimal strings
             * and Uint8Array bytes.
             */
            const HexEncoder = {
                /**
                 * hex string -> bytes
                 * @param {string} hexString
                 * @returns {Uint8Array}
                 */
                parse: function (hexString) {
                    if (hexString.length % 2 !== 0) throw "Invalid hexString";
                    const arrayBuffer = new Uint8Array(hexString.length / 2);

                    for (let i = 0; i < hexString.length; i += 2) {
                        const byteValue = parseInt(hexString.substring(i, i + 2), 16);
                        if (isNaN(byteValue)) {
                            throw "Invalid hexString";
                        }
                        arrayBuffer[i / 2] = byteValue;
                    }
                    return arrayBuffer;
                },

                /**
                 * bytes -> hex string
                 * @param {Uint8Array} bytes
                 * @returns {string}
                 */
                stringify: function (bytes) {
                    const hexBytes = [];

                    for (let i = 0; i < bytes.length; ++i) {
                        let byteString = bytes[i].toString(16);
                        if (byteString.length < 2) {
                            byteString = "0" + byteString;
                        }
                        hexBytes.push(byteString);
                    }
                    return hexBytes.join("");
                },
            };

            /**
             * Translates between utf8 strings and Uint8Array bytes.
             */
            const UTF8Encoder = {
                parse: function (str) {
                    return new TextEncoder().encode(str);
                },

                stringify: function (bytes) {
                    return new TextDecoder().decode(bytes);
                },
            };

            /**
             * Salt and encrypt a msg with a password.
             */
            async function encrypt(msg, hashedPassword) {
                // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
                // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
                const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

                const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

                const encrypted = await subtle.encrypt(
                    {
                        name: ENCRYPTION_ALGO,
                        iv: iv,
                    },
                    key,
                    UTF8Encoder.parse(msg)
                );

                // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
                return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
            }
            exports.encrypt = encrypt;

            /**
             * Decrypt a salted msg using a password.
             *
             * @param {string} encryptedMsg
             * @param {string} hashedPassword
             * @returns {Promise<string>}
             */
            async function decrypt(encryptedMsg, hashedPassword) {
                const ivLength = IV_BITS / HEX_BITS;
                const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
                const encrypted = encryptedMsg.substring(ivLength);

                const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

                const outBuffer = await subtle.decrypt(
                    {
                        name: ENCRYPTION_ALGO,
                        iv: iv,
                    },
                    key,
                    HexEncoder.parse(encrypted)
                );

                return UTF8Encoder.stringify(new Uint8Array(outBuffer));
            }
            exports.decrypt = decrypt;

            /**
             * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
             *
             * @param {string} password
             * @param {string} salt
             * @returns {Promise<string>}
             */
            async function hashPassword(password, salt) {
                // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
                // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
                let hashedPassword = await hashLegacyRound(password, salt);

                hashedPassword = await hashSecondRound(hashedPassword, salt);

                return hashThirdRound(hashedPassword, salt);
            }
            exports.hashPassword = hashPassword;

            /**
             * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
             * compatibility.
             *
             * @param {string} password
             * @param {string} salt
             * @returns {Promise<string>}
             */
            function hashLegacyRound(password, salt) {
                return pbkdf2(password, salt, 1000, "SHA-1");
            }
            exports.hashLegacyRound = hashLegacyRound;

            /**
             * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
             * remember-me/autodecrypt links, we need to support going from that to more iterations.
             *
             * @param hashedPassword
             * @param salt
             * @returns {Promise<string>}
             */
            function hashSecondRound(hashedPassword, salt) {
                return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
            }
            exports.hashSecondRound = hashSecondRound;

            /**
             * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
             * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
             *
             * @param hashedPassword
             * @param salt
             * @returns {Promise<string>}
             */
            function hashThirdRound(hashedPassword, salt) {
                return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
            }
            exports.hashThirdRound = hashThirdRound;

            /**
             * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
             *
             * @param {string} password
             * @param {string} salt
             * @param {int} iterations
             * @param {string} hashAlgorithm
             * @returns {Promise<string>}
             */
            async function pbkdf2(password, salt, iterations, hashAlgorithm) {
                const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

                const keyBytes = await subtle.deriveBits(
                    {
                        name: "PBKDF2",
                        hash: hashAlgorithm,
                        iterations,
                        salt: UTF8Encoder.parse(salt),
                    },
                    key,
                    256
                );

                return HexEncoder.stringify(new Uint8Array(keyBytes));
            }

            function generateRandomSalt() {
                const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

                return HexEncoder.stringify(new Uint8Array(bytes));
            }
            exports.generateRandomSalt = generateRandomSalt;

            async function signMessage(hashedPassword, message) {
                const key = await subtle.importKey(
                    "raw",
                    HexEncoder.parse(hashedPassword),
                    {
                        name: "HMAC",
                        hash: "SHA-256",
                    },
                    false,
                    ["sign"]
                );
                const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

                return HexEncoder.stringify(new Uint8Array(signature));
            }
            exports.signMessage = signMessage;

            function getRandomAlphanum() {
                const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

                let byteArray;
                let parsedInt;

                // Keep generating new random bytes until we get a value that falls
                // within a range that can be evenly divided by possibleCharacters.length
                do {
                    byteArray = crypto.getRandomValues(new Uint8Array(1));
                    // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
                    parsedInt = byteArray[0] & 0xff;
                } while (parsedInt >= 256 - (256 % possibleCharacters.length));

                // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
                const randomIndex = parsedInt % possibleCharacters.length;

                return possibleCharacters[randomIndex];
            }

            /**
             * Generate a random string of a given length.
             *
             * @param {int} length
             * @returns {string}
             */
            function generateRandomString(length) {
                let randomString = "";

                for (let i = 0; i < length; i++) {
                    randomString += getRandomAlphanum();
                }

                return randomString;
            }
            exports.generateRandomString = generateRandomString;

            return exports;
        })());
        const codec = ((function(){
            const exports = {};
            /**
             * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
             *
             * @param cryptoEngine - the engine to use for encryption / decryption
             */
            function init(cryptoEngine) {
                const exports = {};

                /**
                 * Top-level function for encoding a message.
                 * Includes password hashing, encryption, and signing.
                 *
                 * @param {string} msg
                 * @param {string} password
                 * @param {string} salt
                 *
                 * @returns {string} The encoded text
                 */
                async function encode(msg, password, salt) {
                    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

                    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                    // it in localStorage safely, we don't use the clear text password)
                    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                    return hmac + encrypted;
                }
                exports.encode = encode;

                /**
                 * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
                 * we don't need to hash the password multiple times.
                 *
                 * @param {string} msg
                 * @param {string} hashedPassword
                 *
                 * @returns {string} The encoded text
                 */
                async function encodeWithHashedPassword(msg, hashedPassword) {
                    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                    // it in localStorage safely, we don't use the clear text password)
                    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                    return hmac + encrypted;
                }
                exports.encodeWithHashedPassword = encodeWithHashedPassword;

                /**
                 * Top-level function for decoding a message.
                 * Includes signature check and decryption.
                 *
                 * @param {string} signedMsg
                 * @param {string} hashedPassword
                 * @param {string} salt
                 * @param {int} backwardCompatibleAttempt
                 * @param {string} originalPassword
                 *
                 * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
                 */
                async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
                    const encryptedHMAC = signedMsg.substring(0, 64);
                    const encryptedMsg = signedMsg.substring(64);
                    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

                    if (decryptedHMAC !== encryptedHMAC) {
                        // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
                        // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
                        originalPassword = originalPassword || hashedPassword;
                        if (backwardCompatibleAttempt === 0) {
                            const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                            return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                        }
                        if (backwardCompatibleAttempt === 1) {
                            let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                            updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                            return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                        }

                        return { success: false, message: "Signature mismatch" };
                    }

                    return {
                        success: true,
                        decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
                    };
                }
                exports.decode = decode;

                return exports;
            }
            exports.init = init;

            return exports;
        })());
        const decode = codec.init(cryptoEngine).decode;

        /**
         * Initialize the staticrypt module, that exposes functions callbable by the password_template.
         *
         * @param {{
         *  staticryptEncryptedMsgUniqueVariableName: string,
         *  isRememberEnabled: boolean,
         *  rememberDurationInDays: number,
         *  staticryptSaltUniqueVariableName: string,
         * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
         *
         * @param {{
         *  rememberExpirationKey: string,
         *  rememberPassphraseKey: string,
         *  replaceHtmlCallback: function,
         *  clearLocalStorageCallback: function,
         * }} templateConfig - object of data that can be configured by a custom password_template.
         */
        function init(staticryptConfig, templateConfig) {
            const exports = {};

            /**
             * Decrypt our encrypted page, replace the whole HTML.
             *
             * @param {string} hashedPassword
             * @returns {Promise<boolean>}
             */
            async function decryptAndReplaceHtml(hashedPassword) {
                const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
                const { replaceHtmlCallback } = templateConfig;

                const result = await decode(
                    staticryptEncryptedMsgUniqueVariableName,
                    hashedPassword,
                    staticryptSaltUniqueVariableName
                );
                if (!result.success) {
                    return false;
                }
                const plainHTML = result.decoded;

                // if the user configured a callback call it, otherwise just replace the whole HTML
                if (typeof replaceHtmlCallback === "function") {
                    replaceHtmlCallback(plainHTML);
                } else {
                    document.write(plainHTML);
                    document.close();
                }

                return true;
            }

            /**
             * Attempt to decrypt the page and replace the whole HTML.
             *
             * @param {string} password
             * @param {boolean} isRememberChecked
             *
             * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
             *   expose more information in the future we can do it without breaking the password_template
             */
            async function handleDecryptionOfPage(password, isRememberChecked) {
                const { staticryptSaltUniqueVariableName } = staticryptConfig;

                // decrypt and replace the whole page
                const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
                return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
            }
            exports.handleDecryptionOfPage = handleDecryptionOfPage;

            async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
                const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
                const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                if (!isDecryptionSuccessful) {
                    return {
                        isSuccessful: false,
                        hashedPassword,
                    };
                }

                // remember the hashedPassword and set its expiration if necessary
                if (isRememberEnabled && isRememberChecked) {
                    window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

                    // set the expiration if the duration isn't 0 (meaning no expiration)
                    if (rememberDurationInDays > 0) {
                        window.localStorage.setItem(
                            rememberExpirationKey,
                            (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                        );
                    }
                }

                return {
                    isSuccessful: true,
                    hashedPassword,
                };
            }
            exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

            /**
             * Clear localstorage from staticrypt related values
             */
            function clearLocalStorage() {
                const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                if (typeof clearLocalStorageCallback === "function") {
                    clearLocalStorageCallback();
                } else {
                    localStorage.removeItem(rememberPassphraseKey);
                    localStorage.removeItem(rememberExpirationKey);
                }
            }

            async function handleDecryptOnLoad() {
                let isSuccessful = await decryptOnLoadFromUrl();

                if (!isSuccessful) {
                    isSuccessful = await decryptOnLoadFromRememberMe();
                }

                return { isSuccessful };
            }
            exports.handleDecryptOnLoad = handleDecryptOnLoad;

            /**
             * Clear storage if we are logging out
             *
             * @returns {boolean} - whether we logged out
             */
            function logoutIfNeeded() {
                const logoutKey = "staticrypt_logout";

                // handle logout through query param
                const queryParams = new URLSearchParams(window.location.search);
                if (queryParams.has(logoutKey)) {
                    clearLocalStorage();
                    return true;
                }

                // handle logout through URL fragment
                const hash = window.location.hash.substring(1);
                if (hash.includes(logoutKey)) {
                    clearLocalStorage();
                    return true;
                }

                return false;
            }

            /**
             * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
             * try to do it if needed.
             *
             * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
             */
            async function decryptOnLoadFromRememberMe() {
                const { rememberDurationInDays } = staticryptConfig;
                const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                // if we are login out, terminate
                if (logoutIfNeeded()) {
                    return false;
                }

                // if there is expiration configured, check if we're not beyond the expiration
                if (rememberDurationInDays && rememberDurationInDays > 0) {
                    const expiration = localStorage.getItem(rememberExpirationKey),
                        isExpired = expiration && new Date().getTime() > parseInt(expiration);

                    if (isExpired) {
                        clearLocalStorage();
                        return false;
                    }
                }

                const hashedPassword = localStorage.getItem(rememberPassphraseKey);

                if (hashedPassword) {
                    // try to decrypt
                    const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                    // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
                    // the user fill the password form again
                    if (!isDecryptionSuccessful) {
                        clearLocalStorage();
                        return false;
                    }

                    return true;
                }

                return false;
            }

            async function decryptOnLoadFromUrl() {
                const passwordKey = "staticrypt_pwd";
                const rememberMeKey = "remember_me";

                // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
                // since it sends the hashed password to the server which isn't needed)
                const queryParams = new URLSearchParams(window.location.search);
                const hashedPasswordQuery = queryParams.get(passwordKey);
                const rememberMeQuery = queryParams.get(rememberMeKey);

                const urlFragment = window.location.hash.substring(1);
                // get the password from the url fragment
                const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
                const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
                const rememberMeFragment = urlFragment.includes(rememberMeKey);

                const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
                const rememberMe = rememberMeFragment || rememberMeQuery;

                if (hashedPassword) {
                    return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
                }

                return false;
            }

            return exports;
        }
        exports.init = init;

        return exports;
    })());
    const templateError = "Incorrect Password!",
        templateToggleAltShow = "Show password",
        templateToggleAltHide = "Hide password",
        isRememberEnabled = false,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e849ee0f2e16c81de9dec48ecf4524219f63d6c7f30bd8490ca05064f2b81e833e6c1727c196e8b3b72b64429acf6e95b18c15dbcef167871417e8a097716c1d8349f035e3afc4808f98d61f142be18c22dba34f875be3edc55bad44d6cef6c6d9088ab61f107e012cbf3f956450c95c183b534d6b7ab43b88e6d52844de4ddddb6ddd792b2abaa730ad27ec6a586c522d3a9b7844a667d8285964861643194e2ca28ee4cda7d41cb2df5770f2307dfa67d034517542ea6831dd9f7f33e82968bbe1cbeea1491acc148e1eaa7368cadfca5d7a3b02b115284414f237cfc3f7966e55ffb987dae40168e697d6d29da0007460419605c99b773418ce6d6fa6e1476414f210bcf4f7a89b50748394610fe25d660927446a6a9187ab3c0bc980f9d3402d8d3f207bf6f31cc9015a25da7478b79a671e2f9c1d21d37044bc2f629c77a7ceaeae3e050526be573c13ea2b4689d5aa4cd9d6fa0e15b417b4d4ac1fc8e422676b46c2255ad451ed5be3ef18f3fc5fa4decc8413edc707598488c166ea2ced4b699549c6161784385338a3ef08d1be6c7aa9730e3d67539f774b1fb6124f7b50fb050d7b17ced4e4c1ef96d1c16a6c0929401125d8c8293caa143ea00e5f0ae4cb7e49ef3426ec65eb525f2697593aa124543d7dc90e3381ad2d469a7636d2412d6aa83814ef0faeb8c3412a406081db6b97e6190256834bbf6909ddc4fffe157b2fdff2d803bab24b3487f4cd7e0873485fb761fcce15babd09794e258766cb5771ffb4637f95422c8b20351401bf486689e85f1bad4dfff1a14f2b79d4fa99182a17eda64dff933c13c7c421fd71e73b4029b69953918299b12698c777d539bbb57479f65fa27037b7bcd46e9980bd759872dfffc3ba697a6d0f2e9e70139a2b83e74f3ad30b0a8349d5f0c3305e46ecb77c8667acacc4ab345acf0f4b9622aa8df7b1e5adfe5d8f0fb3c6f7bea5524381efe16eef6a7808cdf9a9070e32dbc119136fc2f5cdcb7ff9f19a33837caebabc9cc8b5bf24f85cff23a5bb966c66e11023a3d506ef6a6f6c70840e73c2a34d7b3d21019260a506f6de2b2304570ec92f4b90bc98a831de1151abb49ea3f4e95facfb4d14f88d3e4074b8d1fb521174ddefcf38e95bc4951449cfd253c820d0d5c9a75074818553224b2448d4b00025597fcfd006d9bb282e0992b2f5a30162027d4511eca1bdc752d743e05f92c0e65993f10f020ad169b534de526d61454690af0741700ba4975cc4c1a25ee76e30c8aaa14023a864e3cda86b16a949289131a2b3987604b360c948b93d7c44816895a698e78005b8ec6beedc67a653061203668820ff9a5deff94ef1ee23ada7b2b630fc3ca677de2c3cef9cf30091b3f1584f9e910dd24ba97426c384ff91aca148f354f4e9f5f65551b18904118eed67e71328bd06e5d91c78eba489e6f9a17ed7c9eae23bb26ab0b7dc87590f51bc75f25edf8e5e705c07b5843197a2295cf3acc422f1de3150df6ee52bab9fda006b1f7b5f0d74a902687b55d3b5ecc109903aba74f2da7d4fa0bfb18c925fa91eaa24d1cc347f76e90b9ca10a27e1bdbb8bd4110833ce015db362487602c872e7f82ec7e0ceb1c260b835ffea0e19e74d647d73020e7e2f5a35df8acf28449a5309cbb1292cbdccbab8173a7740b9ff71aa013a9b6933c47ed7a7193f9e917490958276354f5e09a039b195315f5d1bb05844008239c6d14411fbafcbb3cfc9e3fdfd72131634760d53baf45e7b8b7794e249bcf25779d3d2995bc5b44a26738ab0cb5a79ff6d806ee8279b55c352768e33a02c99b75efd5e8cd57751ab0e9be74b9cf5922aee692a377212ac75231fc7b65c3762553617a6dd579e993b3dadbfb713bda822fa299a80d2d46ef0f6d5e0c557f69beae6aeacee59ad537a0e1b78f2d763668ee0314ec15f2b56f8ea363e93ffcba1f40cc9b2b4f725c5ce573c83ea9ece9b0e7310cd90c79179cbecb4f7f8154f687685f37981ec9c310aec3646c54d910010ba62ef6617d32b3b048d58f5504db4694cb507266e833089dbdbcceaddcda872c548a75eb032313b40ef0dcdbe7a7c4b206d4f014591d9bc610bc406d26d88c3cf0d9cb2ed55257d34e49838985986f09389c5f1ff20d9580e790ab756b025d350e2a02cf77b8bfc88d95a598431c9c4b1061d471f4fc473b9b39fbd70a6b0be486c143036a0f33d4ec5c7617e9c58e67dc39d79b5a1f274a2691c18cd68f2a14ac4cb0f36ec14ab0cdc79ce6f0fe6245f88b1df893794ac0dbfb34ef4b4faf7fa10a6a546dcf0aa8cb103522d01742333d1313f5bd7c0d34a549a95b3075d8eed7d6747a09483e7feae433216a98cd2df07469b0516cea7dcc0eb076a8d0632bac5a063482e592a1cc21efa4468b1dbed6bd58e6a894ddc08da32903ba558263c7c44c5c5a4a17f244a4367f28fc2109ac76660557d2fbe9022f8d9a0bf84d59f59994d49b752243d42aba71a78542630b71d23eb4547e6558ccf8c8b8051eaba0aa44dce1a52e756c883ea9944ab7f2863342e538426c3d0daa379d949de871252388588d7dfbd57b39a2f5b2154a341ca0d24f6959df648be827c17d7080b92b1344055973044d248c440bc96fe8681c1bf59d623c27f121a2b26eb021af1b3329130dd96266edbdec17e58cc2f29d180bfde2183f3a99f89d40d7b2790fb31b7519bc02a05d6121ae7d786fb3a33dada27caedfd413fb240cacea06e450f65581787e0e304c0da6b61a0a3f9349642df394f6a02f99030693780a603b05cd530d3790396c6f2485f522b99d394e0870c78db21c0a0180f3b2b3c9dfc0c1010ba9fde367378f7c17528b4d1cb7e2d16075ac4ef215828af115a8d4e19db294cbf37956ccb1292ed78cde77ebc621cd320b876a5323cf4fb1412720c5bb11c953a743e5903a8d149b0b6848c9fd9a61802c5714f59f0cdd8e93325727b9163de05bb182fe330e6de72b80325a4ca0e04bb92cf4085d4e4d3ca07398c334b397c539d6dcf4a5735b88baf74da9dc0adebba46ebcd33b1877fe75cb662fb2cc683d6e4019a60bf3cf797f68bb14d8887ab85d7da2a64890b823cce97e612fce2435f40a6ae8a4d621cfa5a98fdccbaf8acb7cf89c59e458c29811399fb2b15f87ec1773c362efc84287b9ebf3f7767774bcf075478a7b0b8fce0c78b4a3d21759af2ffd5a4dac077e64226b0c4db158e74a1f200c825b6cf74690aa1b70e296dc7db5ab5025590ad8290808974dde2e63d7db2cea7d1e8c75cfbcd452f050c17eef01301727a363c79d61680196c24c5ec619861b7aeaa888e7bc996ae09087a56c54a7bb271658e2b35c2aaa288726fd79dd285e18a1996c025f3bcd08594250d60775a84612fc586cbd82e7d85d358684c33d14e8d02a09cea707ddfc096ad12c20959c2f1049d4da902047550b75908b852b26de7f40a950d989545e724da9e00924a04f5515a23fd0359e9d52cc08c217d2b288cb200c902ee582a1b19ec09f862cd73870492a7ce652c642ad83b971c5ad5960d9a5d717001b018ed13b09ec2073ee5ac5a944a88f78c850e9ed2409eb64f4f51b64b34a53c4e2e26633481276623e4e27a03b25c7c01ff1fc41916811cc4f058f94fde3bf0344278a5cace80b2b52b344725ef04a5b9cc2d25b209d19d9856aa6cccd595acf610788187ce0fb0a9799b044d4d7a4831593c0c678e458f0f0db609887d8b29e44ea48b1ef2e435704cd27fe911a695ad6002874354e2dc5d4870418a7c571026fc2c5c75af0c42df26fa36cf16f1f8baa422d03268cfcb1d1125a042ca48f28ce7701c7203d9192a81a367838c19b0399afd9d1e912a27602bdd0da6ff4d95db3bfd35659df5823e30b13ceecd73d824a9c6993958cb62d2ab20639db65ef1821501d19db124dca9328a0f0efb4a38990c921b62626b895ee1cec3baec49779f111d04c01e1d9d405ba71d92da7e3b3e9218a6d718598a9808de348203af8097211932b152c3544cd9f99e27a2795e42d9958ab03f3bd822b8e8ecf01aa9a2e5df288a2e7e4e3b09d764c3c53ab796d9615989d81bab9c170f1eb682033f0f59d181bad1d49fdb98145847dcaa9dcd8ba9da9ee817c1c4e9e70765ca0382c9465b18ba7d059c0f3f4e08f50ed410c68a117e5843024e29bc5ca57f754ef4ad3e322cc8771a015522fc334668ebfff5c1486eaf9b4a023c61cdde154db61844d0455b464814aefca99adde47e176711270baf3072845f361e55fabf2595618845f7c5f2238918cf83c8f82aaa6112242a4aeadfa8ea63e77262d950bc4aaf755cb5943aaee90c96709bb5adbe315b9822378234dab20f8b8203377f6f57a2dbb19ed0df984c30c0dce8696bbe45bb7e83cb624aa9bd4073875435508967ce0ea6bd5e076cd6474df02e0669daf00f3bcbef7b923951d693267e144d16180f08959c5363a2d9234b815d0dca0e310b9902440f781b87a775b9821abab4489a349bebb32041c267308bc8d2c8a7c77e0d7424e94d7d1e7ac32f410d2796a15ca379471b98ac07ee1fd2dc9184d0d09b77531664970208fc70fc5a3706b540e37735325e2da4cdb09b54ccf421315f39ebc3167d0f8f7f440e2f8500a73a2aca079e099d3fa6d5b2dddda23d20df34f1877222bf87e2d32b7decbd85da326de9380d8a60b4f96682a62f221a9065b75d1174eef0d642f6e63f8551a8ba27457eb4850a3948e6dec1b1c1dece609557aeb7f31c4a001122113a01663f4857c803a6f57ff4e7a5295e31e4c4de25fbaceda8ca3bd452d61b3e2d09a8ae37bc55603f036e8ecbef837a7ce5600e47017835244307857a6da5c8e136e07932513ec44391a4466fe9a27e4515a519d613221e851d8154df29b4497a4df24683627610978c08b44dfcd9d25891534028f558c369e8439bb3abfb36805789fb0d28d091c463103b4c116e023c18811b0dfbcca72cca188d9bebb0083a1555816b3ba9a3a35f15d42f5f7504ba7540b6e3d1628fb17999eebab68452baddffdc24eaa20ab28d526639e276f4b18bf4ba6ffe40a775ffb92bae6fc1c74535c85274c87f1884923518b2fbb316e440aa25d10839a6d70d43a41cc121be4d7f3ab96384f31b7e3e596c4fa34281163af4bca9eeba31e3f6b38111b46c500e3a049e39f66dd6339e5565954bf7d1f8fb314c93f1a95dd0d0d9c60bcdbac6fa8b7455712253797c0bb90af6d53f5331e0bbf671ebd0063e937bc4910d0fdfeb0f5e10b2be37ad69e3706e8a388e1a86bfdd69f5b782ddd0398466a9da425c53d37934ba73d92a7c7f893ed507179c7bab7a8a82e00d79ff71c6e650cbd0e32ce524c4b2f742a0f85d1360f45545b1963439de83008674ad270227b1158523517453e16bbc73b4c4123583b7e69a4965d202708acc4785776c90d17985fe92df21b712d3a3aaefcc1f3b447da06dc80d785aed63d7c5449f4107afdb2257ee65bfb29a8f287d5cf0a896e50b6f38be5de3856280841a7635e64f86941c1bcb8b488c840b8104e848a907638f11cebaa3ced1aec55c6df7d27fb476dfec34b1328ff4e4542eec69d0c970f29e8e0550bf52a5c82ad92704cdf4243f42f9017fb2dc30b732081a1fcaf7f70b380923ddb295d9e7c1119796d5a7183fdd6e7b861f61d7a22724e9c0c0d4201b9dd9509d9fab43fb6bd0ce69c817a2e3c34a866dd47462521e8893aba646b39f6b6f4adbaa80b4be2e32d673f1620d7c8659ee23202768be291e8cd30423bc3f00adbbd3ce3ebec09250d9ecb22123004634de8fa62d810c321a5fee42381f0dce3c0676f84345818d6de6c5b8c336469f2130990a988432bcf9b4a2a5759b9d99fdba399ac095b5f2670746737c0dd4e365c9ae364548200f124709e8e3146152c03119b175684c450b529bc3d16ad339d42364f10f355fd3e521928d6c17123f96c10c0b43356111ee31488d4d912ff7d8b69ffcff2218a9443d9b19ff9599f8a03bd1eeda4fc85d5a585c2ce1d4ced5ca49a3b1af1f920149ceb5b421c8ed01473111c26379e72154974aae1f69eff8f93c7ddba435dc1956727b0f221a600b9b09b55486a8309a8b5f5ec602e02ea63fcaec624cea9d4ca1a670af912405c5da043269f2b7e8bc5df29fb46e333ec751ae8e5fe2edc64ee1e89eeeecfd7ae86e7e7f2086c9dd108e7dfcc9e61ec4374c183c8f212c666bedd75c2c8b2a3879b8373400e7dc42e15a3b9d01318b6e11ea316b443a8b669358ac7b64ed739a712071ca9b7e5e3a03624710ccadb64c67f2d286374f5d104d922dd4ffca97f8be9c62f24c84294bd2207c26b21a82edbd77dc298f9080c53a3dd3ca7f76ccfa4f28525ce3156d5214ee3f5252bf2fe42be90d256610576c8aa2749cce1aa73dab7423f56a7af782b3f38b165c6d4da4e1ab0c5a8ba80195d7d2a78123041ee4a741085fd54c5af4c9f3364d565d8ad5cdcb8e66d5c5486d0970a15d95c606883ea1f0fbe6c3be56060e33c69a3e4e31d10438c573def03401c18676b4c0eaf2712d38744a9a323222eb3024fae8371864e607be63041d8ec32d5bdebd013baf8185cb93e850c1657cb51001b58f68ddd1f353fbe742d095d55e55d3cd2795cf65dc3a1095fe12e9fb011417f37f774da7fe9023f12bbc2029bf276b162f92865d1d4c8efe0181efcc7feb6781988e0242a0f0cbd1090a5476e00aeeb1488d1089140e90382971b296134d010c94e8846249ddeae00f2facbbb42e91f2fa68f6783672169ca17b0bbc047b68713d4c3ed772bd630d8e59d4fc3970409fbe4de2e3387a24280c21d0df32fa99caeb36f797cbafaf30b223d6e6d68e209b529cfc2a46037adf59363a023adf7bf52b32cd73a0aa8ccec90e77eb6c5baa7dea0f1610b38060c885e7aba156a64ae1336dfa5a533755584e7ef76ae0ab7c1bdcc9d32eba8d3557c841ab7ce3b765bb5f7b17887d6de6bf604daaa8254c761f78003de0e6a7c07238364be114512ada6f6e3dff3aad2be9f449a865267eaaa032ba23beef9351c5f341d421bceabc85de326561fd5e7a2e075cd141ffe84e8c8a69dcef3e771ba838eedddd3bf4718f62af9ccb38b23b042a5533ad479677f16be5af539320112f0d2be47239f954ccd5ae98ddd931272f1e5a603995291898679d5f6cbd3fda0f72061dc9af14c25047f45c41d7e553633dd189a0233608b2f845d351f1edb0bbabe2c61526dac3defe723c8a6845766f9ff652a59413b757529b722533b18e9e2f15b04bd819a32a4995d409269c22850c985ffed813561e7ec8c950920afe3c39e79b0f28544253148d11d8a32f0d1d2ac2eb1b383a0c8b8e16adaa7c8d2f56350d64a3f5b78704a96b2628334ac135284ccde45fc65d938cd3fe6ffa1d15db215060a0663263fa607db18d59ca9d656f3c6b015e65499320ad78e9ea2ae41bde1574f30f696d7a81d0048ba90e0d3ecb543af3ace5c13317c5444fe7b9f652478334cab0d37e182898bc36f6d1d7dccec83d4d6722e4d301a466d16c3f7253d560715041e8080498753bf08ce7e622b93a1496a8e59f1fe2b0108aa8168f4a0f7d4e6bea672c40251e89925498ca369ead056863167fb0787a778a24e9e697aa3621a243388fbedf1b78399dde98ffc97c5e09cc01d6cb7326aa1022d13bebe0e6656e6695e5f2b8cf6d7d35a2c8cb45a13476b898294e18bf98248f48fa86175861f4f0342cda837ff26575d4d867401aa4c0c89848bb77453e468636f899411d20bcbfc23e064491ea50de3dddac5dff0b199f17f2fc08662eaeeb80cdf9231e097608336386b925aa725424cb514f03d6aa7599d461b023236e135ab23be7c0c06b58fffe2fcec416c5d21b46fa51cf1854a8700b9f36526678c930ed12e1ae60108d3d3bce2991c0a0544f96e486e48270453b7dff7ba8b79b997255d8a96ee5958617077eaaf86f64758574afbfca5e4dcbda7c025a9c4d48e76738af34602dd479e173c7772e0ae9adcf77db9c8b80da7529039e1debce0a34d8e6c7e6bf64f1261a5c730b0bfffc52d98c9f5e628e082ddc5b40cb90722ba312d51842d854021e6bcb07b07762b5fa11b36d802c2ba5bffde3ae572298bdf11f59d46a72a3fa33257e2fe660fbe4ab2c643cc8bc237efcc53912fb36ad8f8803c404f7a688ac804a704c866dea7307a0168a53a722272e5beefdbf25e2b8abc3b4d0cfede7f9831856ac8bc52cd386b6591a0ae22c5ab9e45cb446df070ddbbbf99b372783f6544e4cdbe64c30b8a23619a3a261864685f2f5f1750217e71423548d461c4dbb2a82d0d3c274fb2294326f59affeb81e752f503f00e8bd7edf92800aab0bbe22cc92c98da7de334b81c1e912e8094a30e48ee691f149a90b8910e1d85614ab1257f1b9f6111b1005d1368a0c4b9903ecbb8ca71e162dcf75a47501472904b4e1e37257d840a2dbbea03d1953da8ba5579335711df78f0e2627c45eb2886ee2b3e2b6702e6cbeaa8ba035b07aa111d306e4f7ef64b6e9fe359c7a2dbf071ab61ce3b330c493733aa2f18dee6f0c1ca58a105965b2ed856423d99340be348d0f205e71a56df787cac01b8f07da69b7c71372d9c3f5f5f98b1d9e18896f85d97d394813fd129064bd846ce33bff97655fb5f5abfaec562bedbc04d969b363bcd446bea305102769f0f1557de8a8f3243e64fd98f13dd21ed806207f0ec1187c9bedbed01bef3dd5963a0092c1441f5876d235c862b997c63ddf0016700b1c9744e6b79397625cf8e63ee6fb654031aaa5dfe12161c9bb3a3415cb6d2d8b86e62ca96cbfa754a624edff86491a2ee15c28b94cb630352e0132ca6bb70e67da3457a310c64e3f0651ce9546705c58bbc595533d5b1581c6416c8a6085b334017056f6ce7514d43133be6c65b5e45e356fc25791cb3f2f8a7da49719fba94f15544cc500bd33c8510a1c5c58bfc42e993139073100a3677d2f441787e94bdd10d378cf6401d3ea1a99c6ca0012c1aa78110358f4ee91015609c317581293baa7a9ef50fcf3eb88154809296743d860b723d5766c67c008a2f7204b537ba13356db1acf83aeb8676ebbd113402fbe028aaf95d06273f870e463b7cf30ae8cd8cc105641fd2efd32af128df0f4330bd4e1ad08fba1327452cdeb55137184c23ffa6dad486e3e56e7980315ef4d8a4fe96a81b83d3c3f77f620d8c3383c4e562533a87599b7a232ee3a2b77bd5a3d14e4b1305bb39c10d9ca5e2f1b338b3a15479bfda2887af7c698d16d442fcb697661a1449746c5d49c33bcc2b50cb770cd50ac43e0d4b983ab9676b118771b08b13618e2279a68c62030dc73e4e7e97489d2d2a4fb32a10ba8940783d0e4df7b134bd74ca4b6486d9afd269f6ff18241b49cf8c86a8b492eac311c07db8e1c1e78f559264e38bbf1162cef4cea7a514701aba1a3478be75fb0a6245cd02d0ff8bbe6ff2143aad91e9860662fec8efd99656a7d5bddeba4e2f89931d9a70859394688e8ae3ca7857a87a497e66678d494a235e450469439594c051fabd576bc8adbed28140df5f58c41183453895912f715db66aca3adbddc7175e546998ac57c467c1d2c0c247221","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"934c14950d2a7b4c7dfdf5b951d6ec20"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise, the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById("staticrypt-remember-label").classList.remove("hidden");
            }
        }
    };

    // toggle password visibility
    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    // these two icons are coming from FontAwesome
    const imgSrcEyeClosed = "/images/invisible.svg"
    // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
    const imgSrcEyeOpened = "/images/visible.svg"
    // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
    toggleIcon.addEventListener("click", function () {
        const passwordInput = document.getElementById("staticrypt-password");
        if (passwordInput.type === "password") {
            passwordInput.type = "text";
            toggleIcon.src = imgSrcEyeOpened;
            toggleIcon.alt = templateToggleAltHide;
            toggleIcon.title = templateToggleAltHide;
        } else {
            passwordInput.type = "password";
            toggleIcon.src = imgSrcEyeClosed;
            toggleIcon.alt = templateToggleAltShow;
            toggleIcon.title = templateToggleAltShow;
        }
    });

    // handle password form submission
    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
        e.preventDefault();

        const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
