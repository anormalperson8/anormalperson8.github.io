<!DOCTYPE html>
<html lang="en" class="staticrypt-html">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/images/waving.png" />
    <title>Locked! | Sunny's Website</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #FFC000;
        }

        .staticrypt-page {
            max-width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            /*background: #000000;*/
            border: 2px solid #FFC000;
            color: #FFFFFF;
            width: 60%;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        @media (min-width: 768px) {
            .staticrypt-form {
                width: 80%;
                margin: 0 auto 100px;
                padding: 45px;
                font-size: large;
            }
        }

        .staticrypt-form input[type="password"],
        input[type="text"] {
            background: inherit;
            border: 0;
            box-sizing: border-box; /* This ensures padding is included in the total width */
            font-size: 14px;
            outline: 0;
            padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
            width: 100%;
        }

        .staticrypt-password-container {
            position: relative;
            outline: 0;
            background: /*#f2f2f2*/white;
            width: 100%;
            border: 2px solid #FFC000;
            margin: 0 0 15px;
            box-sizing: border-box;
            color: black;
        }

        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            height: 20px;
            opacity: 60%;
            padding-right: 5px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            /*background: #000000;*/
            width: 100%;
            border: #FFC000 solid 1px;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #FFC000;
            filter: brightness(92%);
        }

        .staticrypt-decrypt-button {
            transition: 0.3s ease-in-out;
        }

        .staticrypt-decrypt-button:hover {
            color: black;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
            /*background-color: black;*/
        }

        .staticrypt-content {
            height: calc(100% - 101px);
            margin-bottom: 0;
            /*background: !*#76B852*!#000000;*/
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        @media (min-width: 768px) {
            .staticrypt-content {
                height: calc(100% - 70px);
            }
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: small;
            margin-top: 10px;
            margin-bottom: -10px;
        }

        @media (min-width: 768px) {
            .staticrypt-title {
                font-size: larger;
                margin-top: 10px;
                margin-bottom: -10px;
            }
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .staticrypt-hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: calc(100% - 101px);
            display: flex;
            align-items: center;
            justify-content: center;
            /*background-color: black;*/
        }

        @media (min-width: 768px) {
            .staticrypt-spinner-container {
                height: calc(100% - 70px);
            }
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid #FFC000/*gray*/;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
    <!-- My own things -->
    <link href="/output.css" rel="stylesheet"/>
</head>

<body class="staticrypt-body bg-n-8">
<div>
    <div class="top-0 left-0 w-full border-b border-colour-7 lg:backdrop-blur-sm h-[101px] lg:h-[70px]">
        <div class="flex items-center px-5 lg:px-7.5 xl:px-10 max-lg:py-4">
            <a class="lg:block w-[60px] xl:ml-2" href="/index.html"><img src="/images/sunnylurking.png" alt="leftlurk"></a>
            <nav class="relative left-0 right-0 bottom-0 ml-auto lg:mx-auto">
                <div class="hidden lg:inline-flex relative flex-col items-center justify-center space-x-20 m-auto lg:flex-row">
                    <a href="/index.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Home</a>
                    <a href="/pages/aboutme.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">About Me</a>
                    <a href="/pages/projects.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Projects</a>
                    <a href="/pages/contacts.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Contacts</a>
                    <a href="/pages/blogs/menu.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Blog</a>
                    <a href="/pages/miscellaneous.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Misc.</a>
                </div>
                <div class="flex lg:hidden text-center">
                    <div class="absolute right-10 hidden w-60 border-colour-7 border-2 rounded-lg overflow-auto" id="navbarHamburger" style="z-index: 10">
                        <ul class="flex flex-col font-medium">
                            <li>
                                <a href="/index.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Home</a>
                            </li>
                            <li>
                                <a href="/pages/aboutme.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">About Me</a>
                            </li>
                            <li>
                                <a href="/pages/projects.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Projects</a>
                            </li>
                            <li>
                                <a href="/pages/contacts.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Contacts</a>
                            </li>
                            <li>
                                <a href="/pages/blogs/menu.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Blog</a>
                            </li>
                            <li>
                                <a href="/pages/miscellaneous.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Misc.</a>
                            </li>
                        </ul>
                    </div>
                    <button id="burg" class="button inline-flex items-center justify-center p-2 w-10 h-10 text-sm text-gray-500 rounded-lg focus:outline-none border-2 border-colour-7">
                        <span class="sr-only">Open main menu</span>
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 17 14">
                            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 1h15M1 7h15M1 13h15"/>
                        </svg>
                    </button>
                </div>
            </nav>
            <a class="hidden lg:block w-[60px] xl:mr-2" href="/index.html"><img src="/images/sunnylurkinginverted.png" alt="rightlurk"></a>
        </div>
    </div>
</div>

<script>
    const burgButtonTemplate = document.getElementById("burg");
    const burgMenuTemplate = document.getElementById("navbarHamburger")

    burgButtonTemplate.addEventListener("click", () => {
        burgMenuTemplate.classList.toggle("hidden");
    })
</script>
<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Locked!</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr" />

            <form id="staticrypt-form" action="#" method="post">
                <div class="staticrypt-password-container">
                    <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                    />

                    <img
                            class="staticrypt-toggle-password-visibility"
                            alt="Show password"
                            title="Show password"
                            src="../images/invisible.svg"
                    />
                    <!--                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="-->
                </div>

                <label id="staticrypt-remember-label" class="staticrypt-remember staticrypt-hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />
            </form>
        </div>
    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
        const exports = {};
        const cryptoEngine = ((function(){
            const exports = {};
            const { subtle } = crypto;

            const IV_BITS = 16 * 8;
            const HEX_BITS = 4;
            const ENCRYPTION_ALGO = "AES-CBC";

            /**
             * Translates between utf8 encoded hexadecimal strings
             * and Uint8Array bytes.
             */
            const HexEncoder = {
                /**
                 * hex string -> bytes
                 * @param {string} hexString
                 * @returns {Uint8Array}
                 */
                parse: function (hexString) {
                    if (hexString.length % 2 !== 0) throw "Invalid hexString";
                    const arrayBuffer = new Uint8Array(hexString.length / 2);

                    for (let i = 0; i < hexString.length; i += 2) {
                        const byteValue = parseInt(hexString.substring(i, i + 2), 16);
                        if (isNaN(byteValue)) {
                            throw "Invalid hexString";
                        }
                        arrayBuffer[i / 2] = byteValue;
                    }
                    return arrayBuffer;
                },

                /**
                 * bytes -> hex string
                 * @param {Uint8Array} bytes
                 * @returns {string}
                 */
                stringify: function (bytes) {
                    const hexBytes = [];

                    for (let i = 0; i < bytes.length; ++i) {
                        let byteString = bytes[i].toString(16);
                        if (byteString.length < 2) {
                            byteString = "0" + byteString;
                        }
                        hexBytes.push(byteString);
                    }
                    return hexBytes.join("");
                },
            };

            /**
             * Translates between utf8 strings and Uint8Array bytes.
             */
            const UTF8Encoder = {
                parse: function (str) {
                    return new TextEncoder().encode(str);
                },

                stringify: function (bytes) {
                    return new TextDecoder().decode(bytes);
                },
            };

            /**
             * Salt and encrypt a msg with a password.
             */
            async function encrypt(msg, hashedPassword) {
                // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
                // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
                const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

                const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

                const encrypted = await subtle.encrypt(
                    {
                        name: ENCRYPTION_ALGO,
                        iv: iv,
                    },
                    key,
                    UTF8Encoder.parse(msg)
                );

                // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
                return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
            }
            exports.encrypt = encrypt;

            /**
             * Decrypt a salted msg using a password.
             *
             * @param {string} encryptedMsg
             * @param {string} hashedPassword
             * @returns {Promise<string>}
             */
            async function decrypt(encryptedMsg, hashedPassword) {
                const ivLength = IV_BITS / HEX_BITS;
                const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
                const encrypted = encryptedMsg.substring(ivLength);

                const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

                const outBuffer = await subtle.decrypt(
                    {
                        name: ENCRYPTION_ALGO,
                        iv: iv,
                    },
                    key,
                    HexEncoder.parse(encrypted)
                );

                return UTF8Encoder.stringify(new Uint8Array(outBuffer));
            }
            exports.decrypt = decrypt;

            /**
             * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
             *
             * @param {string} password
             * @param {string} salt
             * @returns {Promise<string>}
             */
            async function hashPassword(password, salt) {
                // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
                // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
                let hashedPassword = await hashLegacyRound(password, salt);

                hashedPassword = await hashSecondRound(hashedPassword, salt);

                return hashThirdRound(hashedPassword, salt);
            }
            exports.hashPassword = hashPassword;

            /**
             * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
             * compatibility.
             *
             * @param {string} password
             * @param {string} salt
             * @returns {Promise<string>}
             */
            function hashLegacyRound(password, salt) {
                return pbkdf2(password, salt, 1000, "SHA-1");
            }
            exports.hashLegacyRound = hashLegacyRound;

            /**
             * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
             * remember-me/autodecrypt links, we need to support going from that to more iterations.
             *
             * @param hashedPassword
             * @param salt
             * @returns {Promise<string>}
             */
            function hashSecondRound(hashedPassword, salt) {
                return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
            }
            exports.hashSecondRound = hashSecondRound;

            /**
             * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
             * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
             *
             * @param hashedPassword
             * @param salt
             * @returns {Promise<string>}
             */
            function hashThirdRound(hashedPassword, salt) {
                return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
            }
            exports.hashThirdRound = hashThirdRound;

            /**
             * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
             *
             * @param {string} password
             * @param {string} salt
             * @param {int} iterations
             * @param {string} hashAlgorithm
             * @returns {Promise<string>}
             */
            async function pbkdf2(password, salt, iterations, hashAlgorithm) {
                const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

                const keyBytes = await subtle.deriveBits(
                    {
                        name: "PBKDF2",
                        hash: hashAlgorithm,
                        iterations,
                        salt: UTF8Encoder.parse(salt),
                    },
                    key,
                    256
                );

                return HexEncoder.stringify(new Uint8Array(keyBytes));
            }

            function generateRandomSalt() {
                const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

                return HexEncoder.stringify(new Uint8Array(bytes));
            }
            exports.generateRandomSalt = generateRandomSalt;

            async function signMessage(hashedPassword, message) {
                const key = await subtle.importKey(
                    "raw",
                    HexEncoder.parse(hashedPassword),
                    {
                        name: "HMAC",
                        hash: "SHA-256",
                    },
                    false,
                    ["sign"]
                );
                const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

                return HexEncoder.stringify(new Uint8Array(signature));
            }
            exports.signMessage = signMessage;

            function getRandomAlphanum() {
                const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

                let byteArray;
                let parsedInt;

                // Keep generating new random bytes until we get a value that falls
                // within a range that can be evenly divided by possibleCharacters.length
                do {
                    byteArray = crypto.getRandomValues(new Uint8Array(1));
                    // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
                    parsedInt = byteArray[0] & 0xff;
                } while (parsedInt >= 256 - (256 % possibleCharacters.length));

                // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
                const randomIndex = parsedInt % possibleCharacters.length;

                return possibleCharacters[randomIndex];
            }

            /**
             * Generate a random string of a given length.
             *
             * @param {int} length
             * @returns {string}
             */
            function generateRandomString(length) {
                let randomString = "";

                for (let i = 0; i < length; i++) {
                    randomString += getRandomAlphanum();
                }

                return randomString;
            }
            exports.generateRandomString = generateRandomString;

            return exports;
        })());
        const codec = ((function(){
            const exports = {};
            /**
             * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
             *
             * @param cryptoEngine - the engine to use for encryption / decryption
             */
            function init(cryptoEngine) {
                const exports = {};

                /**
                 * Top-level function for encoding a message.
                 * Includes password hashing, encryption, and signing.
                 *
                 * @param {string} msg
                 * @param {string} password
                 * @param {string} salt
                 *
                 * @returns {string} The encoded text
                 */
                async function encode(msg, password, salt) {
                    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

                    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                    // it in localStorage safely, we don't use the clear text password)
                    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                    return hmac + encrypted;
                }
                exports.encode = encode;

                /**
                 * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
                 * we don't need to hash the password multiple times.
                 *
                 * @param {string} msg
                 * @param {string} hashedPassword
                 *
                 * @returns {string} The encoded text
                 */
                async function encodeWithHashedPassword(msg, hashedPassword) {
                    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                    // it in localStorage safely, we don't use the clear text password)
                    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                    return hmac + encrypted;
                }
                exports.encodeWithHashedPassword = encodeWithHashedPassword;

                /**
                 * Top-level function for decoding a message.
                 * Includes signature check and decryption.
                 *
                 * @param {string} signedMsg
                 * @param {string} hashedPassword
                 * @param {string} salt
                 * @param {int} backwardCompatibleAttempt
                 * @param {string} originalPassword
                 *
                 * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
                 */
                async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
                    const encryptedHMAC = signedMsg.substring(0, 64);
                    const encryptedMsg = signedMsg.substring(64);
                    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

                    if (decryptedHMAC !== encryptedHMAC) {
                        // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
                        // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
                        originalPassword = originalPassword || hashedPassword;
                        if (backwardCompatibleAttempt === 0) {
                            const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                            return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                        }
                        if (backwardCompatibleAttempt === 1) {
                            let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                            updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                            return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                        }

                        return { success: false, message: "Signature mismatch" };
                    }

                    return {
                        success: true,
                        decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
                    };
                }
                exports.decode = decode;

                return exports;
            }
            exports.init = init;

            return exports;
        })());
        const decode = codec.init(cryptoEngine).decode;

        /**
         * Initialize the staticrypt module, that exposes functions callbable by the password_template.
         *
         * @param {{
         *  staticryptEncryptedMsgUniqueVariableName: string,
         *  isRememberEnabled: boolean,
         *  rememberDurationInDays: number,
         *  staticryptSaltUniqueVariableName: string,
         * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
         *
         * @param {{
         *  rememberExpirationKey: string,
         *  rememberPassphraseKey: string,
         *  replaceHtmlCallback: function,
         *  clearLocalStorageCallback: function,
         * }} templateConfig - object of data that can be configured by a custom password_template.
         */
        function init(staticryptConfig, templateConfig) {
            const exports = {};

            /**
             * Decrypt our encrypted page, replace the whole HTML.
             *
             * @param {string} hashedPassword
             * @returns {Promise<boolean>}
             */
            async function decryptAndReplaceHtml(hashedPassword) {
                const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
                const { replaceHtmlCallback } = templateConfig;

                const result = await decode(
                    staticryptEncryptedMsgUniqueVariableName,
                    hashedPassword,
                    staticryptSaltUniqueVariableName
                );
                if (!result.success) {
                    return false;
                }
                const plainHTML = result.decoded;

                // if the user configured a callback call it, otherwise just replace the whole HTML
                if (typeof replaceHtmlCallback === "function") {
                    replaceHtmlCallback(plainHTML);
                } else {
                    document.write(plainHTML);
                    document.close();
                }

                return true;
            }

            /**
             * Attempt to decrypt the page and replace the whole HTML.
             *
             * @param {string} password
             * @param {boolean} isRememberChecked
             *
             * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
             *   expose more information in the future we can do it without breaking the password_template
             */
            async function handleDecryptionOfPage(password, isRememberChecked) {
                const { staticryptSaltUniqueVariableName } = staticryptConfig;

                // decrypt and replace the whole page
                const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
                return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
            }
            exports.handleDecryptionOfPage = handleDecryptionOfPage;

            async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
                const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
                const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                if (!isDecryptionSuccessful) {
                    return {
                        isSuccessful: false,
                        hashedPassword,
                    };
                }

                // remember the hashedPassword and set its expiration if necessary
                if (isRememberEnabled && isRememberChecked) {
                    window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

                    // set the expiration if the duration isn't 0 (meaning no expiration)
                    if (rememberDurationInDays > 0) {
                        window.localStorage.setItem(
                            rememberExpirationKey,
                            (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                        );
                    }
                }

                return {
                    isSuccessful: true,
                    hashedPassword,
                };
            }
            exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

            /**
             * Clear localstorage from staticrypt related values
             */
            function clearLocalStorage() {
                const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                if (typeof clearLocalStorageCallback === "function") {
                    clearLocalStorageCallback();
                } else {
                    localStorage.removeItem(rememberPassphraseKey);
                    localStorage.removeItem(rememberExpirationKey);
                }
            }

            async function handleDecryptOnLoad() {
                let isSuccessful = await decryptOnLoadFromUrl();

                if (!isSuccessful) {
                    isSuccessful = await decryptOnLoadFromRememberMe();
                }

                return { isSuccessful };
            }
            exports.handleDecryptOnLoad = handleDecryptOnLoad;

            /**
             * Clear storage if we are logging out
             *
             * @returns {boolean} - whether we logged out
             */
            function logoutIfNeeded() {
                const logoutKey = "staticrypt_logout";

                // handle logout through query param
                const queryParams = new URLSearchParams(window.location.search);
                if (queryParams.has(logoutKey)) {
                    clearLocalStorage();
                    return true;
                }

                // handle logout through URL fragment
                const hash = window.location.hash.substring(1);
                if (hash.includes(logoutKey)) {
                    clearLocalStorage();
                    return true;
                }

                return false;
            }

            /**
             * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
             * try to do it if needed.
             *
             * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
             */
            async function decryptOnLoadFromRememberMe() {
                const { rememberDurationInDays } = staticryptConfig;
                const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                // if we are login out, terminate
                if (logoutIfNeeded()) {
                    return false;
                }

                // if there is expiration configured, check if we're not beyond the expiration
                if (rememberDurationInDays && rememberDurationInDays > 0) {
                    const expiration = localStorage.getItem(rememberExpirationKey),
                        isExpired = expiration && new Date().getTime() > parseInt(expiration);

                    if (isExpired) {
                        clearLocalStorage();
                        return false;
                    }
                }

                const hashedPassword = localStorage.getItem(rememberPassphraseKey);

                if (hashedPassword) {
                    // try to decrypt
                    const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                    // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
                    // the user fill the password form again
                    if (!isDecryptionSuccessful) {
                        clearLocalStorage();
                        return false;
                    }

                    return true;
                }

                return false;
            }

            async function decryptOnLoadFromUrl() {
                const passwordKey = "staticrypt_pwd";
                const rememberMeKey = "remember_me";

                // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
                // since it sends the hashed password to the server which isn't needed)
                const queryParams = new URLSearchParams(window.location.search);
                const hashedPasswordQuery = queryParams.get(passwordKey);
                const rememberMeQuery = queryParams.get(rememberMeKey);

                const urlFragment = window.location.hash.substring(1);
                // get the password from the url fragment
                const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
                const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
                const rememberMeFragment = urlFragment.includes(rememberMeKey);

                const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
                const rememberMe = rememberMeFragment || rememberMeQuery;

                if (hashedPassword) {
                    return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
                }

                return false;
            }

            return exports;
        }
        exports.init = init;

        return exports;
    })());
    const templateError = "Incorrect Password!",
        templateToggleAltShow = "Show password",
        templateToggleAltHide = "Hide password",
        isRememberEnabled = false,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"30109f3453ee65524d2393e7cb09f2bc3b913c306b9744526ce339e5f2cfa7a131490007e02f27157375fa4d80c1a58155e434ec4ec62a717f35c6613f849584df10304c28b141ceaf5b60441becd71f52ca178243b78033b8fe2b2c069d42d555a5d41bc93f26542e3dd854cddb08129bbc3472407b079774807593beb82c69d7bd56252adddfb65c18ac0c5c71f2a71f68043b4c70acb1b2d96a67d7a798ac1e709155fb47820a858a5ccaa252155f1f662dacfe50d2b2971011945da15f3c8f8135a2de8ce342837cc6e05a424749376109df3e6d5a90b96a82177f8994671fa508cfd93feda5d4015702de4bccc2e3043a9015653087446a4e79ba79c7e568ae2ca73b47b764eb336c7aeb74cfd0439c8da26afd537e43365ddf9dd23e588af2e975692fd6ba4aaf57f9c0a5be24460bdaaf9e8a721f99ba9b2666716ef69da9b80c92853b7df95409650945319b41b64c195660282f5525b3704e2113944c721adebede0522b6e37a88f790ae5755e71b9d4037c28ea6fcc0a8f3a93e3f6ff6eff9e5f0528508acc292fb14390b0b0b7c70a4fe3eb5b834ea6c55f49e589f956119c25c4dfa7cb883ebd895ba181c009b513adf1bbdbd99c5d53647c977573cf525a3d31f136993738890cced1148f11e90c019f85fc0b79f55d529066b837e15df3cf1ba16f5557ca8e19f322b3ec7e94f51ef0067d36a746bdd4866a0baacd90db0e70420882eff7b1b5cba50494eb187af4e58e25dd94d9a4ff2feea0c8308ef2235a6517e561951f549edb5a5f57525833d424606110162300842ce9a71d57ca09371a01bd0b54e5f31c88ba3a134fc4d006a3bebe8136ff7af81805948520e641f8d6fef9808c4c7727f57b706289aad190dd79fc1d64475178b9e351132637ce2d3d5061b38f1fb9472507fdfd7fbda604fd3771b280497f5eb7d684aa889dbe225a045dfbf6c62a6dbbf400e63132e4663574222964b9e569a4865b608d9e4393e869e696db61252c700f5d653ee7d96b52d5b5fd4bb84bf4f74fc7a8b4f32f1969716af1ff59b12bcd6f5a75a4dc310336a63090aeccd76761c2efa20cc856b4e55ab73206c192effa8cc1020897caed3fbea88039a6d1c89db98c0ab934262f1e15ca11bedca8378009076685aa7ffd4409890cfc393956bc2b0b9355d69f4ea3b866ef1ce65bfb9553c687de2f69d82c6bc02400974c09b6722b2c1eca8ae20f02c95d8168314f15f967e2f83c515f6246b7ca59db7423a7371d2222733372c52c7fcd44d36ca8d0500e9f6c06b44e6ab950810b1cb370850d2071fe1cdc32c72aa65659e9e5258e6750904a5af268d5e515e794bdc48b66d80da8e70449fbd7c658e2fcc0da9e15af23fdfff67899d3a342e9ea61f7402c7bbc09fa7b40b10d5361a93ed6bc035235d4141db47fea2c59bbd1119451b707299abca0301efc20912d5124426631ef46fd643d1f80b8e3ab90505ce11abb4a8e7d08c67f7ab827d1c387a50aa6ad41eb07cc3516b64679239094251dbb3231d95c79738e79efde3650dc3b3e58376af743acbe4c6e96bac4e1795325a9da4f36ce02dac0bff79f219444e804484323d5e9bb12e0e82422bfc12060bba660d54ab618a36aa8596e7c4c23c156160ad3fba9af7d5b890b07deb5ca35445dae177df68e0fdcba6db9da4bbae154766929a87fbcbf25dba8bda638b8b6dee8d9f1fae9152d617d311c66eda5ba58702178c914866aa286905bc7d0b9b41104ea175bd16736d708fcd60b05d460edfa27354f2a0dca7b6e8abf6f57b500591bf984faf7d48100d13c18735e6d0a212244a46fdbfa9f3ef8ef2c3150459acf12b9a490d45005397f149ce3e44f7acdfb13e487362cf16ad4f67e10c7ee1a1f5e2f7322205d03cc152cbc0ffae257659b47a2135e7cbd9ea73daa136069ee7768cc0b0c50a5a8574ef84c14651512707e3950719fa4b9dba1359d10f3d9a5812faa392e5d8ee57e21aaacc1e1dab36e9a64faa232d62a4ea963a7509fdba03d0128014c61c1dd8c0eddabd0163778cc4f2bad201abfd9d3675df0da48fd8bf39959eba941a3b695ed331d44b9e9806aed5941fc9695c07b92cf625d413b38e8021d061445a7dd628a99d49e60877c97a01a9b2f96a9bafd4eff86e0fe340e2f5287c96ffa910d1b089cc27f0d43ea14f2bd40d156dbb4bce2dcdf0022537e90ff2b129ae6bf52bdf8f5e41a289b9c022c6a25e13a4fef6cdf93f512ade65257ab0a180888d21a88a7d6506e6ca347cec4a8f2e71efa892354cabb544922e3f6f51d1ddfc52e9706482bb81cd4e666ad8e10146d9006d16c86cc5747554ca371532b0c9b6a545b913327cd83f65a750424f08f87aa183732803c28b0007b80f828385a1cd70b48da036c6dfedc875ed2fc787446d9527256f5bb8c83cf87e88b32ead71d239aa52ad97f2a06c094d6df4a167a8bc4d307b5f23aa49280e579efdac3a4a6e450e77af211fdf784c1a5cb41a53d628258da89dd3469a5d0a95b42cb49ae6c4d374545a0b6cb2a043ee081490852319a2017ed301eb82ac09dae32893ecb0514c2f80be358b86a9adbeb8f4fdc1f0ba5a44a2a7f9b19bec5b99341ec0a232492b64a1b2c2d43eaf0c94fe1207ece9f9e2a42639aaa8d82b8fd9fe2249ab2942abc154a56d9b1ae61ee395b12de9b12ff55ecbb97d7d67daca7f4392bb1ce1256a0a687bec4d6cba2fc3f0cd61140acb2831d45406f07fcaf63a120f41ba8b485a79628438533703f50ef7f5cc7a3b7b89d8037c34c29296fe0d18d665d1e287741afd0e8cb2aabd273fc331b52da3515be32140664f1513fa9cc3807ae4bc3193042f3971c314f8d26e5d3e6f2ac323829035117dbe256e99f9e3be9ccd3400dde3a96de06f12a0158fd62c5832df363144553bbcb8193d3c44ace50a5f3a8622e0ed5ad0b93b177283aed0d2c589766a219304f228d295c3b9b63ae8bc5bf5e558f487b032b8e053b2a6bf250eb593e0b96401d4f0b8eb78a2b16c56332f71e7ae69b9a0e4fcbcb799b5ce8007ce3d8a93818c4243c8e77180b13c15c6daed39a4531b279eed0c7ba0be7b9dbd201a5bdae841652df7de5915296504f8566fbea205c76fb178a5be167107a59d7d70ec4597b0d172a2a2562c959ca4b93ae6621d27e5443184777d6c5a1d13f30f640ae216090ecbb1a014706379f3254689829a2f10c5505f3f3c2e00a5ba9269a6c46e520b483cb125bbda3a8b3fb146098589fbcfc67056d0525403e2573dbc9e8df7d03eb2c378f224ea1ab644eaa49a5c4263893991eb537ce47f0e6a2346e4b422b5029ef6d1a41899f44fd727ea57a7513faa36ee2f14e5cbe352a1eb67169a41f1ee09441cbcff938da212a1020f6c2585cd739943f6fcebff70195ef69f81b6576d3f699b0b49a989014271cdb3ee5ad88f84a01477b967241c95b1271eb51a7a896b4ed18110fa5b6681a9ef6873f1e06d744efc53b85fb02082992c44c191fac9c5d2d6b4196447c1c06467267753765e0abd128e00ef2b1ce297890601400f605701d85282ac52a214172a5556169631fb7bd5d02f3a8f2e4ae5881ad8b185887636978ce50df652423de50fdbf69d94cb8aecd4193db600b52ab39d50fcc66f414689888bdcd97fecf06f49b84b5e2fba8aee8e3e7ef5a014389ba526846f5df39f4910af8199d348d453da8652e0863a6a2c1bad204c94a0cf5e5ddf397ce81c1dc660e92a4abd68b967138c3186fd7c20ddd10fe260a7819fbe5c602bdb3571cf7d56eb2b730183ec0249521034cc453afe429f0c99d0d3167e32abbae4bc240a7754f084b16976c5aba406aa59d272149d2a7e3c98f75c9cce4b1bcf9cb83f4ad5dd1da4cf50a9fd66e95e0a0c1c2565ea7e7be041d15db53f86d3c34500239ce93b62183358262b17f127a00e0fbce3c1aea5c746759c60f92075bd4a08b0094108e5c76594d2db86dc4fb32240c12c93f0c07a3c237b99a93395b1590d4268a1c6fb7eda430e4a48a466df272edeb27a96458442dbb771850086c561d8e19e404fa487d5df1efbb1c573b447b735e5bfe41ae8714a21db07fdd1fe88e956c3e9cf976cd763be216fff955217f2d14471d14f54e2ab20034cf26217ea696018da17a8108065ec8c956c9cabc2ecba17af8b94c3494855759960d6e77867387ae1be4075d1e2b8d6f3334386eac9de7e7b68699533d5110bd17650a2926c7589f2e10a35c64ed59f3e4c464beaa7dd601007d1aff1bf0073f02cc6d977bddcd98d51006e8b9132f13c2dc69ba6342747d2e75b630c03eb60a6b4b6f85bb1514dd3517dd2f5d3da7377d94bd7a1edcb0580497b735d0b302ac1d9273452fd21e6e2b44b08b87127387b4022755ceac893f44a943e5106bb7e3b354ccc6706bf83cf2cb4fc65794cc0339164485845453e592c3334856d102a7fd4f29e3df2b791a04034e511dbc1c2052dec66deb4620deca53342acbf4acd7f38096f20d1fe47893e05729177b1da0242d5684955db27ec834d7a4c14af7986c1f753dfd2748a0565549e463a0c45148ead715e2ba6928f940dc0a6d32da3d37c1b3e74aa36b6a4018c1305bcb9db75e4f4c896abd80eb1efc2730da5850d8485cc639b9894981142cee4490bfe404cf01c229c339af3795cc9a463e01dd3d51fe504327c78e44fb95f1a15e6933d03d6df19c1d593df694c63801fb8485a41ca80a0b0428ad6ef13a27bca37afd0250f9455df226680eb0ed3f939a74cd0d9dc344439d0009c8e32427d1bbf95c11716b06fb243409e3626d0fb2a656532659d0212c6076b0c3e79d60f4eb1640c2957464ebe5ad91b4c2966558262b8de23085b03c4c25d89a77aaa3aef3e41647de778f63a5684fbb774430f0a0d263fd9f1b052cff0780fb308705828d9268166bffe1ed991f6fa8df92447f5340f90699c400d462a1c6ed37201008670aeab9aef45f339d2f301c90d1f17b51a45828ef4679b8632e0ca628a83c73d3f5631b0a799d5d918405758d25669c95960d4c6ab66c2457566b24d0a03013094f31a849e4c53d345f95ece006e6474b59142dad0762258a069c2cf2a9b040524acbc0d920d7c898eedea4fa60cc9bcaa9363f5086d54c84f38ddb04e39f2f6bb1dfc43bfe1816e5e5dcb584ff5dce51d47f928a91b2a8735a60cf71c68b799ee263dbbc4ee4b70f3f6eec15d43916fce464ac646311b0715759d01ccdf2706f2a064a517a9f9257922c0082a2eb31f2dcec787c2be6fa503f1ce2b2d3b43528154477336de4ebc82435fa3efef6004482ff88d6a0744b9ee6565bb17cbbdc6cda281bb9713562098be4c2c9dc14a5090cb2890cf6e45aff874648dd8fdaa630742ff6b08dc0e188be571c1d06a9cdf3dff9a7d4e96b27f017875b29f9d1ef68ce1c18771bcb4dec2976d511ed84c8b67934eabb7ce1366438730bf9f64ecc449206e3fc73624746eb67c547b09de5b0217792c977573562c33a834d86f5697d756320d4efd016e37c00d2f9120995a2e36998141094eaf46374e016f5e421ec29d9610781417fda3d3721b819e3e76f869706a80cda542dccf7edf5aa43248dc6d7d815815b25e9bb2cba7d36e5de7d035b8d18e048850bc8e3e3f30f7d909f69009c44a085fba50c87a8a18fc9beec59cf5e20fee80477e28806e7cf8bf1c2c539de0532fea5bd050f3f534dde167e2d0fe9438fb2cd743850790564cb2fff686e55ee8a794f6acb3c92932b8d4462d84300a4fb78efe1eb54bfe2d5d2b2ede78f4572042bd58c898db1bf41a5c50a606c84f16500bea79eaf1b31c9f6718b1d9ee03016476fe4a87c82550eb6c3e2f86bc708af27efe0a3f9beb1bb091f21efcc190296943509d1422d0564b590aed4686538743ffeefbbefde2df513e460f7fefc2431c221be845b74e39a53fc86d7c0a256772a5ce46fa1bae5a53d37f45cde7d4b7b3a2e7e5caa6c8160cc02b9da767f8f40710e94932235bfa88966621a3b9359adc43cebd96c5782595e07b840c765d9f2b577ae90cd3da9bb8df679c8a66009d9402a5fdd730b314b75d02359e6bc347d54cb355eae2152d44bbc60e53e164f9ad31a71582287a496d6857121dd83243aeb73b7bc2c85a1033b1129218300d99326d36801d74e1388c78b0f396ae028d5f45ded2e81533e7cde7425acf638d7cb26c413934d1aba253761756470a2a530ee6fcd5fe66f5daa2f80dbfec2b607bc099039d8cd7b53ad23cd60050ef8019ebce3a23fd299f080ecc6ba72f714d53ecee385e2b1df13786ad7165db9aef8adb8d73807961caa32546ebb085306b58bf67911626e21cda2541a373adf4e8b97290969b92e28f580bb89307c9e2554aac7c7eddd19512305abee24bb38c31e6974ff1092781a5dba5717ca3a06edd813137297cd1c0fd43e469affc8934e05d557cbd8fd1a313d1b6a7f12577a15b1fe3be653f6dff547499e0005e977db81e66dcb7242df15f85c5e91f0ab1e1e7dc963f5221b14155d1661540424e0efba7182f52bed91d585c29d845eb144dc47021cde75ea06850cebf2df8854ac24a15035d617061b6aeee991b7ef6d96da1d4c5426e315d8489e4f61b6fa2c84a2c27feb68d23f472a97933b5d18951778e0c4e785a7999e073260cfd79d2e2f7e11ad9f2ac0ddb3da5d97b4af5ca2f8c35d6f3519d6c933dedae644c4566967933b83e57aab04bea89c70ee62140085e639bf088e5308087bdca4e97838e2c71aeea230593ca734c763a603fe2211a30258b8a28fd50ba46005b1ea88ed1063597c72d2b1106c6c961b15c9657a456d7a8684dbd388ab2453323fc49380b521b0434374f843e1868dbb1ffaf8e46f20ce17cfa5fdf45b78f46431530b2bc771c48c1b816c6e667d5a413491528455ba12ac3d702ba0d2288696877f951af05886609337c6c79a04e10a835245e3d4c803362a4ee2042e6ab57dfb3e644e5d0557c3f02a18ae46492a956728019e6e4828aa8627c7d7f1f330bdbd035ea12e1096b4665893d74868c66c676b32c0d6d12649ba1825ae1a2e8281ba2d56bb9dce55eaf9febf273211158c12bd16a878b7003e90aa1f392d811875dba23bcf03ec391f757b85eb2a2f3eb84a4db72d0a1f8ebe224fcf43a282f146299a01444e1d13e5b9a181c00aeebfe7645a194895573993064b531c01efb8e71aae8938aaafe015efe986061c4dbe5a7e25f421f2bd3fc0cc0e79dbadc29aa118ebfebd50a44d2578054a3d9b5607637e71b6516641b9e600b76a1d8f0efd761b0edba2ff949048cd78dc5dfae620f2d4e23bfde57ab92131f4df239e3556c0c6e21688e502864a8e77dc60b735794a42550277c8e16c09acd2c09d25f93320ba3c22079b7119c848ce4b9aa9d43d9d40ee5f27780224adec94e7aab3d25ad1dfec2cc726b49bb9bfa4b29da0d2682e8930ead597b5ebfc3fdd79364253afe7aac16fc17b7741637d2d80b84cabb31bde848148a039cbfc06398480aa507743a30ccf8dd9bc15de21985541fe19f8918269ad67926b8a88996fad8eed4efda89185e1335c1f2a4160c50c9235a1c2d3a79c901cc100636fb8189e22ae3e3642ee5ac5c54d1c552b44e6a0a12c1ccf3ca718305f105d38275df6de2ce47e631cc5dc83114e9943ce9a4d9438a855e2042a0bb6eef64a8b935dcdecbaffaee05d799e8a243b6fa4cd514d3ec17974d344ed156e8a4877dc1b378295d50846d89d69c2ca1e6b5005e07860ef0726dbac96db39160308478a2af405a57cb9a95aec00dd51bfc17d3ed8b909af1a5aff712a0626d960144bddd4fde6e29578b500a1320fbf2a304de2f0259c6064125f21e13e703734513b4811ddc409e459b167fd3c4bf2bdfae757d7de216b00d952bcd1122ac6b458d35d589667f630ba05494b69f4d34d93dbf05b42dc48c47a5ad43b57d42d436b0bdbffd82c8a4975824b05efc2849ab81bda063ba7ffb5565c59cb3c64117c0929eba762e56c1aae99a286d8fff796f9640f963302d64691e4f30fc7fbdf274263446d6aeb1c8011fdc4ec1189df1912baf15e02f18db156c058b4a69f11c548e92108a83f5b919e3ace253f3f6aeb32231ec06bfff12e0bb47821e2d9f203f547af9526291c84ec959bb0b75ae9b57ae4911dac4632164828111a025622a5b13d4cdd4ceb6ce93a0b874a517fd4e525e559a0ccf165530425c905985aa24be676ff0f03f62a3689fe5d606a3b91967b726eb02837a4aa0ca1e98872fe5b99345dfe19362f7ba1897eafd7e4a42e57b5821ac62a7086df3876f626c4e3a4511fb0f6deb43395e4f3af13174244e6306551ac8b9576a9ac77383c1475f53168a9b863930df2bb328caf982eb970853ee73bc2f3f928c21f67c4a6cd1243a1e4b0cbdd261361d92167d5bd31f7a777abcdf408806ac325cb48c259febadd03adc167c98b1d9eeb79a7402dc3f2fbaedb4a113ac0b7688ecc63878b6f9075f1565dce6642450dcb29697c2ce5d1131d068cb5fe887f4f89022e859f2625fb4a716f067a9696558002d414cbf32ab0c1dd40ec3fc8f5d7303d7dfdacec58649eb90c5897bb366fe87ab5af37f2646b994436e5c26f177586ee489ee5a6712771e0454f862a140004bdf2b87f7a2886957d12f76980e5a1be5450e93937c726c1a4da4a25b235541479d71d6b15a00c2becf3b3776f503f54b5dc891908d24d8cf2b21c357f4ef2f79c4679e9b09c29127c93c1a716e891fabc99710d6d48376adbb6bdc30658e52d581840cb70d17dc853cbfd86f1f59273ccd03ee824975fd5f509150edefd129c891a0954280361e139afc93fdfe8e9965f17ad9683147bcc79dc63de170ce4c16f4c46d8b43440385f28215120ab025ef01f10f7b69aa32e698cd0cf0fe04dcc5d15df285bbdf3c36cbbaf441a96976d58ec5700652c10416ba8f9b2f3c9c3c584ed39ecab5027723fa9e6894398e0766597fca312ec4a54fd4384d27","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"934c14950d2a7b4c7dfdf5b951d6ec20"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise, the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById("staticrypt-remember-label").classList.remove("hidden");
            }
        }
    };

    // toggle password visibility
    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    // these two icons are coming from FontAwesome
    const imgSrcEyeClosed = "/images/invisible.svg"
    // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
    const imgSrcEyeOpened = "/images/visible.svg"
    // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
    toggleIcon.addEventListener("click", function () {
        const passwordInput = document.getElementById("staticrypt-password");
        if (passwordInput.type === "password") {
            passwordInput.type = "text";
            toggleIcon.src = imgSrcEyeOpened;
            toggleIcon.alt = templateToggleAltHide;
            toggleIcon.title = templateToggleAltHide;
        } else {
            passwordInput.type = "password";
            toggleIcon.src = imgSrcEyeClosed;
            toggleIcon.alt = templateToggleAltShow;
            toggleIcon.title = templateToggleAltShow;
        }
    });

    // handle password form submission
    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
        e.preventDefault();

        const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
