<!DOCTYPE html>
<html lang="en" class="staticrypt-html">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/png" href="/images/waving.png" />
        <title>Locked! | Sunny's Website</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #FFC000;
            }

            .staticrypt-page {
                max-width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                /*background: #000000;*/
                border: 2px solid #FFC000;
                color: #FFFFFF;
                width: 60%;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 15px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            @media (min-width: 768px) {
                .staticrypt-form {
                    width: 80%;
                    margin: 0 auto 100px;
                    padding: 45px;
                    font-size: large;
                }
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: /*#f2f2f2*/white;
                width: 100%;
                border: 2px solid #FFC000;
                margin: 0 0 15px;
                box-sizing: border-box;
                color: black;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding-right: 5px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                /*background: #000000;*/
                width: 100%;
                border: #FFC000 solid 1px;
                padding: 15px;
                color: #FFFFFF;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #FFC000;
                filter: brightness(92%);
            }

            .staticrypt-decrypt-button {
                transition: 0.3s ease-in-out;
            }

            .staticrypt-decrypt-button:hover {
                color: black;
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
                /*background-color: black;*/
            }

            .staticrypt-content {
                height: calc(100% - 101px);
                margin-bottom: 0;
                /*background: !*#76B852*!#000000;*/
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            @media (min-width: 768px) {
                .staticrypt-content {
                    height: calc(100% - 70px);
                }
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: small;
                margin-top: 10px;
                margin-bottom: -10px;
            }

            @media (min-width: 768px) {
                .staticrypt-title {
                    font-size: larger;
                    margin-top: 10px;
                    margin-bottom: -10px;
                }
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .staticrypt-hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: calc(100% - 101px);
                display: flex;
                align-items: center;
                justify-content: center;
                /*background-color: black;*/
            }

            @media (min-width: 768px) {
                .staticrypt-spinner-container {
                    height: calc(100% - 70px);
                }
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid #FFC000/*gray*/;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
        <!-- My own things -->
        <link href="/output.css" rel="stylesheet"/>
    </head>

    <body class="staticrypt-body bg-n-8">
        <div>
            <div class="top-0 left-0 w-full border-b border-colour-7 lg:backdrop-blur-sm h-[101px] lg:h-[70px]">
                <div class="flex items-center px-5 lg:px-7.5 xl:px-10 max-lg:py-4">
                    <a class="lg:block w-[60px] xl:ml-2" href="/index.html"><img src="/images/sunnylurking.png" alt="leftlurk"></a>
                    <nav class="relative left-0 right-0 bottom-0 ml-auto lg:mx-auto">
                        <div class="hidden lg:inline-flex relative flex-col items-center justify-center space-x-20 m-auto lg:flex-row">
                            <a href="/index.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Home</a>
                            <a href="/pages/aboutme.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">About Me</a>
                            <a href="/pages/projects.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Projects</a>
                            <a href="/pages/contacts.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Contacts</a>
                            <a href="/pages/blogs/menu.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Blog</a>
                            <a href="/pages/activities.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Activities</a>
                        </div>
                        <div class="flex lg:hidden text-center">
                            <div class="absolute right-10 hidden w-60 border-colour-7 border-2 rounded-lg overflow-auto" id="navbarHamburger" style="z-index: 10">
                                <ul class="flex flex-col font-medium">
                                    <li>
                                      <a href="/index.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Home</a>
                                    </li>
                                    <li>
                                      <a href="/pages/aboutme.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">About Me</a>
                                    </li>
                                    <li>
                                      <a href="/pages/projects.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Projects</a>
                                    </li>
                                    <li>
                                      <a href="/pages/contacts.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Contacts</a>
                                    </li>
                                    <li>
                                      <a href="/pages/blogs/menu.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Blog</a>
                                    </li>
                                    <li>
                                      <a href="/pages/activities.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Activities</a>
                                    </li>
                                </ul>
                            </div>
                            <button id="burg" class="button inline-flex items-center justify-center p-2 w-10 h-10 text-sm text-gray-500 rounded-lg focus:outline-none border-2 border-colour-7">
                              <span class="sr-only">Open main menu</span>
                              <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 17 14">
                                  <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 1h15M1 7h15M1 13h15"/>
                              </svg>
                            </button>
                        </div>
                    </nav>
                    <a class="hidden lg:block w-[60px] xl:mr-2" href="/index.html"><img src="/images/sunnylurkinginverted.png" alt="rightlurk"></a>
                </div>
            </div>
        </div>

        <script>
            const burgButton = document.getElementById("burg");
            const burgMenu = document.getElementById("navbarHamburger")

            burgButton.addEventListener("click", () => {
                burgMenu.classList.toggle("hidden");
            })
        </script>
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Locked!</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="../images/invisible.svg"
                            />
<!--                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="-->
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember staticrypt-hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect Password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b12b283c729f7b6ab31ed24c0108f2bc52366ec6f4c04cb73596bfe607bcd6c08c064c3edb5f23d84be54c7238bbd564dc8e608168ddb36d845caabf9d7e5c5ceaabd52284f3772c7801588a9e9c4cb24b324a701681003c2dc6ee926ee9fa7ea26b6bc98e582ef9578ab7d106e602dde5ad4434f8b8354e5e5644272673fec89efdeedfaeb6b53d1f8cd11cb07475fa6ca5d989ff59f9ac75b7b0cfd3484447c5c0e6f43971ad9b722e9ebf2a69622bf43a0842969deec4d787493491adefe69dad7ea831c815a03080b78ea57a7d2020bca680a2a1c537a28bc2a947b373d6f8dd58c60f174c3f647614838259329f2e798f3d51300135139463b017c61b2b36eb2c3cd46e45bcd0e174a283ae797532178da6f4bee5f1ed2a7b814722a116aa98d1343219bf1158fc85b3d5834694ffe8a68484779ad5559c181a2ec2fec6d842086be9333e683e75b53f2df018a089e94a16b7b6b3ae7bf6e29a525112817ffda0703b47396b3095032740687b31214adcc37da86df612f9faa68d16ee57ace05f8f767e402cc9145357be429be67748c669c9d06842d4e4743e15ad5ea39ade0ea66d4abd080518e8fcee636df700f09f5e613652f0ed9b525f5dd2b00fc665e1faded7b881e8f0d45f0c94d61785084c30467ee1275957ec4193a4226e595f914689a34775e1a13628ae9b7fb85dde87e90b2b9ae261515c1bd22466eb4708058873c3e8861f476c8faca626f30e55d9b0197e7ff193b4856e433f45f4fb7430cf76bc021ab6820980c114c7b8abf3d1b1d5a9dd67d3e5b829c2ec196d773d95e4266caa05f3b1a0f7b000b2dcb6f4789af666f95c3960d2fc7f27877a73cf3332e41cac09319c4ba062bed46d512d5e33d4e8ec93430423e993f636d09cb63ce3d38b8dadecf82cff1901cdbb01d3aa84f0f23b7831d349b1ff695e4cde802330147a5e04eba4dc7ff1fd3f7299277ea2823377c068b6c033612074d59e1069cd8818f5e9b386c2ab6e5c3ac0c9f585ef1287b229d64aeb4716d836f9fefefe8bebadf1e57ec61b1af8310dafc04f5d14844ad9431104af69622db953a873590973c57ea98129907426e7a46ce070f8ae8703750fdf95c459815dbc19bd385afbfebf8f566cfa1cdbeeaaccb5da6c02b1a56d4aae7b3b96a84b9bc39a60902bcd50b92a820e7ef64418f74779bf2a3f64d7f952267c410897246989b6372ab2eac73040cbc77400b62a779d5e97912e90109ac3bfb77d6c62e2c5fa4d1c0bed8b71e23e840cae3d2e6bb62ee9a5127b6167f8a7f1b85900b08e34817da9695e30abb33c76ccb39f8616af3285679396627494cb9b4d50666df27f8cc320bd4e7e4547a85d58bb63ff14812b8d531d617aa16cd3f7da3e2800b86ba923964d27e7f4d08835e539764aaf0bb2fd25470b1e66056b51554f2df5cd081ea0e6af99bfcb3218da6a5bf425cb11f765779a7861a01b13c08bf4d61337420dfa5fecd7f079c7d04b2336b0801cb3b6c0d1f12394afceaacdbd204437c7cfe16a3c99f301f4630540701d588e55fd6772feb6cbd2416ba5d76ada66be4b8f7417c01ded31dfb5c4558e5914171e81845f4b6f1aa7b6ddbc519c0cabd905374fce956174f32f1e2864fd5cb59711d116d39064b13cb4fc9f29228c6e90410a176ba37b09bf396eb56ef6dc481fd50adf539b83d34456eb5a84c939915ad267988297bbef28fa25a492e4c9ee8b7c6c9383253b4916f5550dcdd75a1b067c644e8d21606f11e9962c8f99b1961e98d730ac5e59d749c103a724d4f60ac01434147d752a3cbf543091843e28472e27a5597caf9c19233c1ca50fa2f4622a9aefe7d35667f4c4fa042385a45c972459ee10fd7384862fddff918057c9b02bd8c9e09f85d4a52ee708a05f44ac631d08fcf5df6250224774a5ad69af61f2eb332de3c35f39e435c487adde57392045faaac2ca45737b6e0534c7eea5dbb56d36a55b291adb4245ea03a0b6d7e6bee0db0a2eec436082606e56f5649c52fb0adc5325921155933e755807e9dc272ab33c01f80aca52e3aa6794c02c2900e53b711937e218d2d003bab21ee6ad641150be809aab7f24e61540723d98bff2d505ffe90620fafda1fb49b4b3e205c2f31bb08d65dfb4661e778c6f76ad9e4d44a68bf15205c864e680eac8ec39d844e5bfc1f1123853c5463ed9c86a4e563428b47c84322a5aa3e2e072b0be06ac5268535ec1ce99a8e21e479a75ed01161cbcfd0a27a27c56aad52ad9fd0717f6ff8263058fe7f406d90b8c75ddf93ff109ecc98a59bdc4ac76c7b61ee348c8f8354f47f843142c523722068f4232bad65be919dbfb9d347a0c50f15cd1ecb35f63cc75fc05b7fde1f1243347449821c1709cf948e9d62b94a7e90c82207bb49ccaa3d4e29c7e2ce2594562fc700f5b94219881c1dbb58fb5b074f50a101281959963b2daf777de4cb50ea0d2a85db0db0470abb30d301e68520af7ccc684bae6ddd26edcde86fed5e14b5baef937057c01ba4ffe3e8cee3bc995736581ee239131790ccfe255aecf16e4b7433fb3ef27cfa38bfb46e779e68959bd13dd860eb6c244373bb5255f89681b908fb6287c604a1d05ec92f30dfebac77ebe7588495a01e7ccd39c686152166dc0c2ecb1c50b8b658ac56a989b54b33fcebeebc6aa29c52ea5e3e0de89db67cb0d277a73b59a2b8634e9af652fcb5dab870962b0a7218d12b3c4598f24d91fdaa53028dab0a0643beb8bb099f8c9e779812c9628a8b656a740efa8ebfabda05b8bd3f45d073039424a18eedb39610a3638418427f524a08427425eb006728fa4b29e9afe1c2155de443dc0a38e3f955240bbc6eca7aeb59f819a071951173e99fe624e0320a8eb39a2c8c16c7b04bcc7c10d8de3004764d5f3f78327222ea0fb51456b391d1a5278b4d91d8be970ecad662f9b2bf4c254b9aae0c6e6fd99bf51511f18377d0cb862f6d93089e7386b2b37948a7756dfa3bee5dcfa60e571964ffe7231768eaa3d35c1d232e9db1787190cad92766bb2d6d33637faeb8a6a53630a98b0644136c36b1d77d58043f17183f74fd399f4815f847f2ce25e5582611e819fff872e5157b1374d3e5694b2a2f316708d78803d6bad03cc9948b3a72ce1be33babf26d24d61183cb903e49e22d34e7bbb44f053d7116cc88b25fc1f7e6f1c797ed0c8db23825345d750b5d89cce4a767ee1f837f40fb7eed87c9df77e983587c97b2f2abe0ff7178b1c34bdc24b83dbc2bfde34641b7328528afd90564514877f43cecd480c57b2a5b1ff4df9bdb1cb215f16302294f150145cfb2a8d3f62c2b3ff9a905c0f87ab645390c6de2280fbbc09a0c6bf999904d91952442e78d61a9039ac71c53116addbcbdc6f7bc83fadb696f9cc1d47b22ed0745155b0555b6cc72ac70875bade028b87a1f53ca722047b3dde9ec8205873462dbc91ceae8fd6bc28b4d8aa7cb1d99da8a34aeb409c820ab4e981c876f28c34f9635518eb0ccdd5f6d42120b1b951a6b419cd2a822fbe8d1ed331a17c56cfd34cbb352112b7032bad79cd669daf85b82f036cfeb46f3a161925d878dacc4517140f2908f7e1a0649dfd9db9afadb767aeb157ad745d158d23dcee3db18026245f651431b0d20c829d686ab5a98e84baaf7ec9710240c7107e8739805a3a68c99868cfb4712ed2cb716931319546a839850c8434ff4bcf62f3468b395c90bac87e955de30072591ff2b7c04b5ee69d34683fc1ec4b3b3027707a8fff8f1d456b72336ec5ab49febbaf5b9c53d78adb5662449ff0bed8bd290fd6171d572986589bfe1051179dfe906991a43b05a4aec783cd2268c4c8ae336d4cfd42c49544f9d00bee3f1170373556ed88798ec517169b510ba57a6950e7c2014f9c17e8ef3755ff1d93161b2cab96d37043df431e52ee8e5aff5a701067b9c84e3adad029d62223d3791e81850cb6c5b82b32a93dd761fc39630ca5737b136e70b99caf82ae8355210ad7859f840532b1ab9c7747ce17ec45f579a7ff3827bdab46f8cdcab72612dbed2d77100386e39456668c8f635c5426ba05f3f589061a44cbe41a75a2ed9896433cd758dc52879b8f55075b5b7c1de55d1b5af3bcf9a6aafafba97075c3119790489b212b549735321563e2a6c611a717a37eee2e1de841d336695e737249b74b8b534bd410056003c2a7406eef69df1c1c25e5ace0d44fd6ba8639ebb179658dd5f2b4213583c96c1cd4f89a94c19817bba3da980c61df0e5f7b39d8dec65ee96f186da7d3d7551b793372dffa9b98a4af6855b366e2b07e3a69e1a19bb6e8392bbc202fc42c641b8eb4de807cb7b68de02162122cf4b87c49dfcf8ba89b6f0f1bb9dd5a81136511dccadd02b11f8d2f457adc90a5ce0f3573ea11d419ad556a991f00f38fae9c3ed01f67b0892fc261f6dd7b46b81b8c4e7edbb639a5af639f4f62e39d0d954a65967716a9d1ea9c863562a334741d9b3381bfb72677b48cd2a66c8c768bf30dddd389b23f3e404e2ad0b5027ce7ca45cfc6b42a07a546e18f1d70aae885b3df7ffaeebeb9438e0269ad4247d5be4a950e9f0b2146aee5ab92b9f7d93a21b9f602bba9704c619a8b8a596f3937af488ddc76d61168c8aee4aaeca7c218fb9aa63ca815cb87c3483fb417ddbd91940b494a3857a908f9a24b555b8f9a1fe0186b6e1a0a18779d32ffb83c1410491e576cd0f83f695f631e52c332efe22a2a6efab49ae06d4e6604b29fa5f638cbe2014231379d66ab87a65c49b34bb3873dac2a38ced5f18eee0daa25655f22a1aeaae3301d198c57fba64d6b5739479e12582c21a393fb08a9fb2168b1d892f7dfc28787e8da923ed41522b0d095b5a541ba6b1421a132681f1a9a85a5f6f9707c7e3f0ea3dbea30615068a07b1106d09ecfb7fdbc3cb70966595ffb26566d4e2880ac320266d8084588660ecd3216a23f65878d3176fb4e0dd2344f097c4d4c6b8a24893dba702b927c8ebcb35f16baee6c1ea52bf8c34f85dc82929e0dc7ab73fc4cb13cbb6edecb1c10e36d184c5990ec9d57700d36c32ce1ad2a457b81129be6f02f82bbcac096b885ab670b1f21213229d907d5fafcac5c29c2d8ccc41b3a95e218ed1fb56db3cc01704ab15bccc0a1d54f5b403b142f6579aba6901d0fee82d86bf9fc5dd674af578c89c25532364bf530d7bc7ec8779815c4db851158e39001c90f29d4f17b5ffcaf9f8096a98a43bd1a368ebee4a4c0083c3ca152457bc242aae63d832cd84e6b72656022b87584dd6d172de4b0a553df76cf04f47f6c3442e861fbd1de5fe1f980acb749e22f58973c4346a39bb721721548eb6497700275b129d6146e0a450524e731eff490ed7b75d6c4d88618b02bb898ddfb6cbc1a1df9927451bbd3bd57281172124e517b78d301907716985d86172bf95388432fe5ab3c303d1d528cba613f10f6b809c4b346309a4ad09f6bf2eb4c78f69c986f792e561005de3eba6a8bebfe3a5c987c6b20fa191c9e5ec9ef2f4fa7912a5f830a3ffbc61e85b40f0231f83c620425bc5d3bc5ab70fea9600d3555f20d47d28b7d6c9d4a2b6d30bc4d87e2f03ee96e790fd45ed8bfa93a05490d4c5b0f16499ea0002d091253fce2b314de586b9a2596333fe74e4ebfded91cecfe9a2d4fe1df3f9f745766dbaac23d67345ba6258c8f0105482657136df57d00e71092f6c4410acfac70d5b1eec65be04b753e4418a24ad57129c75c3c5a6c7d57c085d99ef541f48dd040b2d38194dacef510f2d22748e615cba9b616e400c2494c9510e55041cd5a9ed7cfdcc60181ddd5c50a16515a9dbb561f0dfc05477674643b91b81a3d9c560176bdf321b361400583b81c1e79eca71cc7fd67e745bdcadc08cccedb8af37517c502fcd69b2a780e8d8133bbe418ca543310fb0987b09ee12e80e14b13fb1b486ab357f5cabfe35d2e321ba3c4b28c96285a17ad909b3028ecc288320bef23863ae2ad1a6d88775e2cef6d3b178d9426d5fd863f3b4fdad8514ed7540bbe67110df2cd25935afa113a817b3f7709bdc55206f4f89f37300f4ece7bed3c24f1143f3e4e57ad20edb45455f8dc461ea84257e7f05c00c8f39da283f128c7b2ca880513806675988be708b45ba924b73fea8aedcd559f4f66d9bc3b0d937b0915b20707e3129bea738869da9b077388f3a3ad8707edd6868c18815f623941d01c64b9470d499d8debef72ae8299b9631d3035e0f3d96dedac3791ae9586307d7214c5d7e82003a9aedd727de6eb47e46fe290a0b791bcd76f5859d529bc721b9510a6bc6bfa2ceed89cefad68ce1368de5a896fa0d3d4a4e2340222e7aa8306a50a2521fa0befee5dae65ab92aad3e3deee791a8186644635acc5a04f4d1779930b27e8757cb16a33bc6155ad5e2313a7d400fdea303efa09d00d5305acff875bb34eb05b84555b0a02d8791692e9f52fb70e67a67b009dd6bf53781e1d198a1cd27cf13be1254fdedc8f15db37138256332b4871f797af03a6cd7edc55f052d7647fee2cd98e40d9e01558098414a734fe2069dccbbc15449df07b7a07dfe9e429506b698a178a5e6e07dee5703c08fdf7fbfa25424a8ee7dc4d0f08d2f0e37f2058e28a3d7aef2bb0634301065b3261386b7f18ebb167213d8ffc3eb399ae103399039671a9bc1152bc672348525cbba7c7843efa4c96ab6389f8af63213853ef111d3b19120cdf3d8f51cc82172740924738ef16cf1097fefd1d6b412ae45ada6f425156608b7d2cc9425c48133aaf494d83d1132f986fad1f50837b7f6c7b806d778b92af02daa300cae47426f62a319283f0390f6d05fa7164af4dc2640035d5837fbe1050cf08a0c9884e2910ba6f60aa087e14a43e5f4ae7104dc643db5a37648dd8aa113539052933153d1e14698e1ccbf3a886f2e03a9a080ce9c6241de8cf1692a8a8ea8bfc1d9b2b91efb97e92d30cb351a4b80b98ba9ef18996d210b2cd68046b059500834d950235968ebb57603e5df09f362b4320ccd250a7312e68e8d7fafdfa1d89411f49f72bfaba8cc1cb898b78c7d3dc7fdb87d833296a798d9d7f5889c87a42996ef9c62738f1fb712672a3ab11cd0ce1e84662243dfa98aab214bd2158cf8428319700f4ee6cd448f41c5d0fdbeaa0be6c7c1c99bd589e172702923f11eb6008d5e35a23765116cd70fa9e9cc46a193517aca97e91e6775e79d7151d97e6aab5e24a2e02fdd6af9a27ebd6c6be68c86e7e9e43c08830dbc590d78323f351c4b5d49c64584ac57764ce6a2f02a9c3587168c2d67aa68cfdb58af200666c9fc342bb6f660ad7e9ee7772fa82c0f282aea48ea9f2b6f03d021a4f82e30fbe86e2f6b1163cdad63411004d81c1185113d56c269e7e41f8ca74e495e72278007c8364d3ae759f23ddc513eaa4e9ecb0f793dd41da0450e9d4393528410721f5f100cc7e9ba38153441e8fd879d06c985c05d083de6fb47f04899763f210db17959268351c37bace21381f06c12b194fc1a35987329cb199e95bf137e25e313c9cdba9c02e02983308a2644678abbabb65a041b3bda6d2f2ae556b4f1b2a606150ff9dd3bc4b6dd358dbc3495ec69da9a89521aaf496181d5e56128eb25ba15ad478153763c6b15aec46e39613dd209d658c525f5d26eaae04dc8090f1fce4b962a0bfcb6d1abbc1cf3d3b45d60347a85577d456b36e5ffec7005bd877df3a441e96e0d734cea4d7491b9a1d232828e55aceef5c7b0d62612db63a6dd529ebc971377215c082daa596b948a852844c0e3ed37eef09d0a52e8b1d9c58e6dfc7a3dd8a8d8098465d1e3e1a274c067563b384bc5d9a6712c7af0d986fc90af557b5076b806e98766e607879658ca2498d52e8a8b8dd9e51c70edccc6662bab8ee15e7ee1ac1bd5aea8423c2a3b50f09a81c63323acde4c86a98610a2820e41a75c8427174d0f0d6be024d0a89f54bdc3b3387548f2bb98dccdacce658fee9b4f01c23ea1d8350968ff6643a672ec631deb72b9c91e51ec0a8d4967ae3a607c7c0b8601ad94f90ba63b24d4e00b0cb7166412104cd5e3c4f113f60cf1507a46b8eb6048c4917c970dd7bd9abfc86c65d47e4bcdf1ed89766ef7db69864fd29e9996f8e245e9b67f5ef708130e85475e51ceab0239479f2c6bf7d2cd5d5eb6fce2da96ba45ba8b3c55f77584733d06fadf473122b3f0eb5bdc422b34ad0fd321ecfd2d5d251ec19c1b6f52d5a955bb4228d236791135668f265ab19efe1bec2dbf03391d5bbfdd2c0d06d89335edbd3ac9d9a7b5c860c709244463983e33fe9102143514a3294c213db6ff9089761e5cc579e01a2515d9e9bbfd1b4bb0eb8096b376abe7858e10504e5657e3049eda9c61508bcb7aca52c5751a9d94e717960f0d72a845a5ac734b1cc17a723788584bc957537689cea6f75b60d0d9d512b850da8d28ad53590ea22053cfa545952850d97dfcee1a774338dffdc5d298ff589cd687824f68936352dc9efc87fecb7760ccc9f8092dd80e5cadc5bef52063bd7e89c12ddf8592e08a284d8bfbbd705fa2e36c47f94f6592e097cdc23cb4078bba295ff899b0af4c4e88808e76e9cbbd21865757e800d3779b9b914239c0f121741c013e459457ca7024d82ad9a1756e70b8de84aa3614137770d63521c673c77d30e1b286eb5ae620d2521b07823321a8a975e3730d189a5c41649ed4cdcabe40cc4ef66c94dbbee4912309dad3c407d5f3b1951bf62296a21486bfc827337f922f292909c3434e7ea8483ad1c53df72b637e687aaa20d5520420a9a9dcc5230c45dd7f311d93210b4883b64f845f5ebbda0c5e727611a1f9b114b56021ddabcdb9d36dbb64a01f072ee7624ef53249e79fe91370b91b617ceaa80f7c9e796d3f0ba7e1d2b96373728bda6d9702b0310165209037677ead04df67c5589486db4e5abd0ca1d6eb24dd69aa95e64dc6c8c0ab6cab6a603ac9e59c139dbf6859c353b29010e353883becb6f35db7e3ccccbff9d2371d5ea44ecd269ae81f89e90b84619a0c6fe5b12cc31daad4ee6e43c4b35a9999b7a467ebe3438126c36d1228d3805809abf4a19a50a07697a8ffb64fa4fe9a71a82aa43b0e7a581c53e5e849cd0a3473eb8e29baa501bbfad88763ff20619376ce5ccb508c4c6670210b746793fa8931c3a987152ef1579e1effc3a9d27738f2ece37095578e883e9bcbfa5c9183532595e580447d936fd26ac8c8dc2933dc2a4f15bd268d3e4bf92418298ecbcc2be75e6627e1f90675ea89ac688fd6a0b4c82e1c902a12fea0b0e866981fa8d0bc7e6706ceb3dc64460e8fb48640d02","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"934c14950d2a7b4c7dfdf5b951d6ec20"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise, the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed = "/images/invisible.svg"
                // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened = "/images/visible.svg"
                // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
