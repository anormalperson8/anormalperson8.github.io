<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #FFC000;
            }

            .staticrypt-page {
                max-width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                /*background: #000000;*/
                border: 2px solid #FFC000;
                color: #FFFFFF;
                width: 60%;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 15px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            @media (min-width: 768px) {
                .staticrypt-form {
                    width: 80%;
                    margin: 0 auto 100px;
                    padding: 45px;
                    font-size: large;
                }
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: /*#f2f2f2*/white;
                width: 100%;
                border: 2px solid #FFC000;
                margin: 0 0 15px;
                box-sizing: border-box;
                color: black;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                /*background: #000000;*/
                width: 100%;
                border: #FFC000 solid 1px;
                padding: 15px;
                color: #FFFFFF;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #FFC000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
                /*background-color: black;*/
            }

            .staticrypt-content {
                height: calc(100% - 101px);
                margin-bottom: 0;
                /*background: !*#76B852*!#000000;*/
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            @media (min-width: 768px) {
                .staticrypt-content {
                    height: calc(100% - 70px);
                }
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: small;
                margin-top: 10px;
                margin-bottom: -10px;
            }

            @media (min-width: 768px) {
                .staticrypt-title {
                    font-size: larger;
                    margin-top: 10px;
                    margin-bottom: -10px;
                }
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .staticrypt-hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                /*background-color: black;*/
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid #FFC000/*gray*/;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
        <!-- My own things -->
        <link href="/output.css" rel="stylesheet"/>
    </head>

    <body class="staticrypt-body bg-n-8">
        <div>
            <div class="top-0 left-0 w-full border-b border-colour-7 lg:backdrop-blur-sm h-[101px] lg:h-[70px]">
                <div class="flex items-center px-5 lg:px-7.5 xl:px-10 max-lg:py-4">
                    <a class="lg:block w-[60px] xl:ml-2" href="/index.html"><img src="/images/sunnylurking.png" alt="leftlurk"></a>
                    <nav class="relative left-0 right-0 bottom-0 ml-auto lg:mx-auto">
                        <div class="hidden lg:inline-flex relative flex-col items-center justify-center space-x-20 m-auto lg:flex-row">
                            <a href="/index.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Home</a>
                            <a href="/pages/aboutme.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">About Me</a>
                            <a href="/pages/projects.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Projects</a>
                            <a href="/pages/contacts.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Contacts</a>
                            <a href="/pages/blogs/menu.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Blog</a>
                            <a href="/pages/activities.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Activities</a>
                        </div>
                        <div class="flex lg:hidden text-center">
                            <div class="absolute right-10 hidden w-60 border-colour-7 border-2 rounded-lg overflow-auto" id="navbarHamburger" style="z-index: 10">
                                <ul class="flex flex-col font-medium">
                                    <li>
                                      <a href="/index.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Home</a>
                                    </li>
                                    <li>
                                      <a href="/pages/aboutme.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">About Me</a>
                                    </li>
                                    <li>
                                      <a href="/pages/projects.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Projects</a>
                                    </li>
                                    <li>
                                      <a href="/pages/contacts.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Contacts</a>
                                    </li>
                                    <li>
                                      <a href="/pages/blogs/menu.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Blog</a>
                                    </li>
                                    <li>
                                      <a href="/pages/activities.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Activities</a>
                                    </li>
                                </ul>
                            </div>
                            <button id="burg" class="button inline-flex items-center justify-center p-2 w-10 h-10 text-sm text-gray-500 rounded-lg focus:outline-none border-2 border-colour-7">
                              <span class="sr-only">Open main menu</span>
                              <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 17 14">
                                  <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 1h15M1 7h15M1 13h15"/>
                              </svg>
                            </button>
                        </div>
                    </nav>
                    <a class="hidden lg:block w-[60px] xl:mr-2" href="/index.html"><img src="/images/sunnylurkinginverted.png" alt="rightlurk"></a>
                </div>
            </div>
        </div>

        <script>
            const burgButton = document.getElementById("burg");
            const burgMenu = document.getElementById("navbarHamburger")

            burgButton.addEventListener("click", () => {
                burgMenu.classList.toggle("hidden");
            })
        </script>
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="../images/invisible.svg"
                            />
<!--                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="-->
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember staticrypt-hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1b6d20470205ef01ae0eb637d1aee1e118a3b28606354fb73dfefebbfe335a511f6a671bb61286eba8527b2545be154c4a0293e748865d08c10e3a3e151d204e369df025f523734032c823b709c38ae40234a31f094884c724e36df930a69b8b985ceb1033e01a6b1e5b13b1e474415e4c51deb3fbb3f86b9fac2ab165900fa00b96e84182fccee063cac1bfaf9f5ba123eb54961be55d1f2c53f59b17ab6af82b982aa8390a8d34f44219f8071a6b32b357cf0be0ee315cf9fc842fab160a94aa67c6c6daa6450b6603736d526bb588da9f93ebb1e990610610b14b14cf64d7fd5febc2f3a89c02710c0261a768abe69eb3f52fc39ff3b78606d1b064fe29e1f1f6ead191dedd0b58ebc886e91e8f1e9bf63c6afa0d0538038619e76c618913e48441ce1cc7e20791eee1e61940858bd9e1f6df85433234c0e52dbe97f59273614eb1925ce6766023dab4878aa1d0c766f164e3ce95aaebca8e05d9c8445b3f97c15c38747cebde255573ee8b3f0d771363090e242e737148365e0c73734f95bf062a4da2c2cbd070f30bbb997ff9243c524a318a5fd44106cac5b8dcd410e85d244b87f7a6d3353ef7357f35eb25f1e6b77e6c04ca4384b0f0d4f0e9d540fa44a755a0a6b98e3716f5d7a7ceba84e82f6c56c06b570f9ad05ad36ed896a03b307473616b28cd64eb0a462ec51d241993d69fe164ef50736e945a1792037519ebbc87891da98fabdde51f0796f7b7c62fe4241665d70d4502c4cdbed165241944ed19325c4844ad933b60621497d9c64b7bd20e8a807421fbbd97a02d8c40a9ca26fdb3872ee3e08c6b9f83ba0ac41f5ccbd0086ea47558973ffb8dfdd9e88d3940523b0d2f0eac08c91d5a60df9b21776b85de433bf11a6313ed74f1bf0df15a8a10f77940613103fa8507b42d9dadd0169ae34df892bfa35ab9d491c6f5e7fc479c75dd889e728a86ecccd63db72ae3d42ca9298698d84d203b2d2175443092a99f0124bc6c983d3af2147309707897b16102f9568ec7bd541b206e7572c7fdf5004da40282f68cf345d6e0c45166171293f9d4fbdc63208e69400c332740021e7e45cc298bc6faf22ead0dae43645a7cd87ff087a3a7f40a5ccd7e35e6f02ead2cc6392dfea8e4148f499d9eea2291c9d729bdf71c9a71a440d938e5b511fcefb4229a5c14b57ea12f50809f2a235df55873753739d6cbc761dca14afa94bbf9218f58a1c377b1b57dfb1e0661700f3af84964451055e6b80ed3a09bf3c3588efa17b3e128bf1f9c76e120da6e06415727506303f39049d078dd97311e40169aca5890681c585e1d0398a055856202540d6cbd09ba1a040f5050621f67a090cb93edbea69cdc96c59a142cb9f5d521b335a8e2b829ed2362b715c676e32cb03f3971c6a2a7ce2f4621c8bafcee2cce14115c6d98fdbd544f5372b6808571e01f37a5e0aea4b31181c0e4b6b52a5987312bea866d04caf46a3caa582a8dfe1e17a7da7b35a3deb8146856fbf1a452dd6f8242d8f38a324b4631a2f481a208c5d43fa3b6c2a9c636cdf573e6ccb81756827fdf8b4284e06bb4de4f55a0c3d762fd7c289bba8b4cf48757ab7b3b67fc1d845e36b92896ea63a41777883d079d7fae1874fb1c7563762f2b6e5a652fa20e3db4ad892b697184793c7d536518d883d9600b8ceb0c1ae17fb7a160238102dd89de9e601752063bbf0db035025637698db6a719213c89d7b22a913985882a338b0240118f04872b677b6972b4e96fdb54ba9e0b2fb1df559d7f33b0788d6b5a927b7ceb673d1fb29c56d842c4f999d7295bea109819512255bf82774c3246dcbcd37cd867aeb76b0c59fa18551f4383628dce3af1efc8ee28e879f5e5555f52699847530c22bdb959b8a587dba5b7679859ef5e8cc81ed2eb43276a3455c033d6f305d688b206abb103b8508c80f499ebd9638bbc953c5d84f9aaacaba4d8ed2214fb14fd492dd125a18efc36d6b42dbcad1fcfe439551c077c7febc06e006bd595658315ba086955b85ad60515a120a09dcbfb3c6604510dbfde33128d313836fe4f859efa3f6e765a807dea683c2581788bb4e3ad250daabefd035943957fb09b35b3d0b8b8df73df58cba7ac1ad4649d1b34a83dd2c5f8e6f52767d5a397fe626849448f591a04e3d487e58dc94d0046aa985e5d63985bef77a7716528aeaf2a0c08cf4f385276d064bdcbed6d1971123b0d9c7209d80bcc0dbe89874b1828b5d7d62a56bc9df8bb0b8ab788897337614d824a1157367ebbbab18d506334550811619290d1040c0cd941c706e709fce1b7afc410b3db8edceaa303306e7f8f79c72e557db7b3131cfbcd7162009165fa1f17235ecff67b1427ed2d88e80d37d9fabc2017fd29d68a550e92b26281af281c32102ae85d72baf4d0f0f233a8154b9a3521424f7cad30aa2a25419e413082b60d6df517cdcb682c3fad5482cebc68e8f396de5aeda366eeb7d06cd132eaa73b53897ac19aee8a7190f9c28b88e10cabd9af092b517ed9dc84b78b3eab76649ebd1bf77b5484b6f2c592c3b309a96871b21f04a15926d5eb2a73e5e9921d550a85dcab3c277fa17aac0e54cb8c7652520d69cfdbd124f1b90002bdf533ddaf37e5fb0bdfa2f316731693687b3cb2aa8e9812e0571b5bb20f3e8afd3744e0dc3c7f491055c78f3414f99515682f6f620afae32a63996381ed2876fc50812eb0724b4b853c1c9925ee13000731a9be3df30482099a2d82432b8b863e7f4476cf3bec8de7549cfbdd3523dab9419bac8f68dafb8df18f7b4ec6ccb71170727fb070f09246570cc285714d55d2e2721cdcfbc61160163a89ab333b304fbd0d3d2c999baf570a873c5eea9703882af463dc5d1c6e0d7fac3677754509f2278b9638582d5d6007f64b7690639be0b7ff601af38c39b43475a99b257ef406e9263ecbd63483e2e945b087de7530d2774ba3a95bde4a3afcf56da9a193821e1808996cb323fc7acd627d3f2ab6933c0f6beb29553dbe7a301f84cec111f055216d788716d1167b364eab69f3d492ee47b3ae81c7f14643a055bd08ac78126ed5455ea38ca76dba85dcf83cd864e748d06487194df25517880c562d41b781f889e56299d87bb20814cabd5734e2a480926fd2eeca7d52269e1f3bfb1b05e2405a07ace3eb84dda0344e1c315e9851c64748cdd23d295f667932956b87001e9e16d4499fc0a18644b09670beeee5a732ba868d09017b2050da747a03eb6fff47bc611d80228b37152c0e25619d3d0637f598d5f916679d8c1678c0c05fa27a37e488ef99ebde7c99cba5393033c5522c522ee7b535ad922ae93b7d44bd46dcd09b2951cebbe029ef2b8f418d7b869a9fc963b2ad6819b9d31c703a1cebf6a75bc0db6f6df197f00e79bd4601471b192348576c0a40717257642a61a73a5ee9590d1b6e3202c265b0a433bdc6ba5102a3210f19e70c93dde7f8d2ec19ddbaa96aba75d85c58617c30ffd247f4fae1c32522a1f263d1345b5b6d17545a80d08ff67887c075c8dff2ccd44cb8e8213df98a53922688900fa0fd3fb3922cfe643e66a66cdfc82b6c1eae1d6a70417fb13c8507c044c03b9726ae57e4557079f771d8ab3947768d63c92a4295c103fa48700004648c53fa73e6e1ed37e475f31c6252ddc60c4efe2cae0efb8614b51de38b17d5d2e483cc457180841c9ab18a7cacfcc3156d0395a8f07112085c62ecb1c3e903a8f3447be479c6bb00a03b7a68f1c77925153a79ab42949b52217f89749b41875a5cba646c1cb9585f13d411a3d62f007661b7b97998b866e286e06a7abd6e86f6ddd5fcb2d0b0de9650303488c819ba042e7be837322b5e81da71111903fbb440f68a6919e0a2af706527caaea237baed9431977dab11df17bafda9b2a132f4dd68021fb95fe92dca353cd91c9d1a03d352993152aa4a9e2aed51f37fc7748b87e8d78560f3c8f425cc51a5527994c8a3217fb491255e8f33d848cb7af6b09dbd3f90466c3bb88f029171d11bd633381c72c930bbee596c55d245aed1976d59f29634321048b8d5db62b4e692a6d4d9f89b2b02687574f34613907a5d895186bb9d879a5140c48e2312994705b1c3f09e937229dd60ed6a01da4616280d5b1b009e70608087a7461f0e726149f5b15d6674798dae49ecb84962bf632c0c3a1a83d8f4921e165a5b7208b7caf85b00b5ff166f94678849fa3d5435ccb7c7cb1b69c3e9fbc2a800df90d4449f146b74c557fba88d434c9b3e862ac676e53908f2331f7336f77b8c2b37db9998a77036dc1726cf5565b7906713d7d18bbaa1f873e68b1de0f3edc603379fd12f493b6d3b0254499c4267975730ddbead83ff24edbe8382e8d502938a6bb53b9f5d7019a1184f6f0a316ff6b1a48e0123a93b2bbc48e304f946a2dd970e8ea255f6f7b6a065eb768ce4f40761faeb9c7850e6f6ec2cdf4986ada9e48474f0f4f51bd625ff0d6e8902a1bf4924332bc45cde057bf1235b7514fe839e95392cc85c60ab7c18bbf884b4bfc0c7916a19b5d28635f30d2f6c9ae5492f9bbbabc33ed4a6a3abbeb8293002185e35a804d91cdd2e8ae39dd107cb86eb53eee8c1308c83772a16ac6413c839a743520b3e283fc8ece51729dbabc1633098dbae52fca8e9efa17d765faaddd10904766869612f11ae5109dbe58b4ace8f57eb004f31b0710c40c7e567937c1ce0cc8a26d1637fd9731f548135ee12ff9a550fce1d147bcc474d33decc3e9468f393ef51bd26b134b0cd9ffb83b7cfe985e5a3ccc3f889dbebba0216756511fbf02c19af45fc8c6b1a6b1d854f73d692eead7ebcf6b042171d1f8f0290a2c8283f7f08958019551d6f17419a7eafa7737f52d46eb88dbfed20c369bcba8de34835758936993daa56888764fb98208e558e0754ce00e71ee34e8c950d745890847ef0f524e94507c752b18bd07d31ed3756273a7adee08c4d96d02c5bebe4e94f8673360d193c0761273c83af54d08fafec20f13dd5f26ec864d6499da207181c3aa0f72dae7abfbd2a75d7aa2b714cd4c6ac1cf6be20071f0ca9ac5bb4cb5fc672d1449ff0ed42e6cec36031d74ef9d7340f67bd23e454d7fdb036c2f2ef115aae3e5a7c1580f8dea4590e02976b2ed3e215852eec974606abacd615d84a4bd2dc9ccd1ad44d5b247b666453d5049e120b4599d53b77c32006d72d48b2b9c56c0466d1eab9410511fe7f586e350511956cccb7a482f15881ff1d754440ee15ebe7ba920233c66f24d33ec42f1fa865b5252bded09979409810fca98e4cbe629e9ef4388fe4723ceb8fc2e209f72bb84e8691ff9a3b94f3fbb52142e38111244a32349fd86fcc984aa7180bd8718b48497c45bcdaaf53f57518ccd034bbd2c12b54fb1aaadec60239ea5e35fa6e488b0c1c0165564b692f29aa1d04f650f6898a515e626d87a9cef1a8f30394ec51b6b017b20ae7c8442aad72807669c3d18b261c97f244522ffe56fa5b97a25c45bcf22b7349c4e6e4a4fe6260ca41020624e155600f629f925dba4cbd8b627de2bf91f795d6e27e653abc366610c40d036d22a90359504ebe2acf06904f916b4334c6a4f353f7a3f02c3d75e9a2b874fccdc53fa784b82a5fbd51cea4a598282b10b4f152f14a5cc70103c8b1205ed33e5505bb5dbc864ea9d41eab17c1068430cb08ad9f497668bdf68e0bc969c0b51d9fecec1530ab3605e3a0838c98d40c9748bf77da1a10df802e43f3de53a68dd1470a49985c3c572b1dbb975b98b73700240c854d22b6be437bb03bf73f115b0a523644b429f9868352fb033b726661b495e9396b497780043a258e3a27c72733f6427582d457dde40ffb080b314042c340f0bea7c72ccbf174f444a21529d87f2bb17c9f9824ddde861ddf1e9503535ead92326d7d0198640dcb37dba40da84cce2aaf90d226f0c0690e797809c31de5641b47bf1323102595e5cf1c94060e1eae24ce66024d8b22bdb812d77437c2936fd507eac23d1f126625043974f5d9dd52a14eabf3c0a8667be282e8625d71eeecb22c8efae4e4017fab48bf56b8390b9c6da581aaafd402551be6e3aed3b12c6443cd5d1e473f80f5ac8f3d4c5ab161f6350d304849f92ca8bb32ca0ab56fd7731576f636b8ea3b16c87c63c58bc12cee9a2aac15da0e8a407078b7611e27e6f6dce8ba2ee08b55a68e23bc590d218410ca5e8e5a483852d1d46307cf712e4908dcc55e3ce15475bbc030df89a0fb13b2282f6ad11e226765b54595727f749f2e8c770a9c1a637b4857c248723b57b4adbd1ba288b68860dc2cef45d8bbd529e0e83664ccbaa0d6c3d7f7eee8739edb88c17f18f521257195114eeaeb14ca1d374b47f6b8d2b018db2055499df2afeb4dde68c31724ff1a790e8a41ceeb02efe228623081dabd8c03d0f0a53b99ee9a3aa71f54fdeb160478484eed72fa298df45adc5a41d19e1df028861f1a67bd43cf35687455e3b8a90ab97425449b29865dfa8fe62c2055fb258016fc95a99894f52b36add2cf41275b6b0d47b465ad94883b959792cbe86612259b182dbe73c4aa8a95c9e1f784b35b637a122eea817ac6df80a02ca7300f91a277ca4d898218ef1e9bf57021231b6929b218bdbecb5de7e5e8e02f9123576ddcf2ca114d9f5a642cd2c97e1f799adda6ea0b944f0c06bca8d6e7609c599788a169e340ac2a757849434950d176a02ce023fb2a2f28b2a1c9f95ebfcd7d887b516025d01fae4dc278369ffd08346e8c185d3cc1cf180bca35d1091c6a604fb715541a31e725ca06ec8b631192b24e6d0b1d2ba8ed01b955d8e74da96dafe675c9cbaa43b174654f5e6b8cbe91b2b5725a8d640c279b10d8c1b9a518cda8ef18a330038d44a995e34f65995082c6ddd054f317fcc9a3d78c307a5db8e9912a710e1e3ff75b16bc05a68025b6d555626bb43106755599fe0e3bac4b907aba5a0a50183fc39cc53d27c753da87d041b27c692a6ec034b97ba34375ea8270f9d076ebea1f6310f9cfdf3ebf44020224b3a630824014e87bf5f0e73fb049763e777676f329e6f0ee47e4e1dbb223ce1245fcb9bcae78fcf94e4c588448fe6fa3479d3e1df1cd2d74143be6e64067f36f83b73307c12d53b933c485cc039efedb8a15b913314966f01eb8a87836135f49fef1eb64e0a48b004f646b0bb6f3be789f260534f8e900816847c1a4a5b79b03c22f2031e4bfa3d37351ba9a28b97c26b84f56c8d6a70d2f1bbd0588771a60284ff9853eddabb3445bc70372d3da5c42035f569db6296991358df0593a4180dde2aa3ef958d3b248df15f421ef78618aec5f3cf3cae26c33a38041d402992829ed169cb5bfa11b22b03de95f186723b7172bb92a5bc68c1e667f7eaf98106d85e50e1a094d8c723c800d6b3b4d38d64b35ae8b1d425fe6cd2c938c5f5a16996512c4c032490fba31521905b1d4a48c0cc7bee35a4a8196ca0beb6ca1bc1a3fc6c09100f433f93e1f112ea9fae037970ca9453540ea39e29bb93f3587655737e9bb31d85ed52d3cedf0082084d255de8ba252dc7b7684e4160f845f7b2155c7c1eaf0faf4c8cdeae938389105ccc029bde80927623d19f737cef2a4c5e2c3f48928418b100d9ec49c2db8d5ece0f2680cd0a1c17eb043ddc438060f6cf4457ce5fb54f6f822db81ae8597be350358537490346bd68fdb1f62f5c72f075c440af924c0a009f2b14af30a02f92d7d88ad20513664185b74e26dae58e4eb2b7a9a86a4a808d6285e0a0bf7105dff52f9cf76cddd7339fd2d7a6c1a363efa2033f4ac20b7e89c8f3171ceed27807109435afbc70b61736636d97abfb40c8d1287fe34ba7249c36bb9dc8a13ef586c96986fddfeb74fd79c4fedf2cbd609e8f30b1de620ff6a2114507de4447a5d957eea7d4af79126cdc7b6f0048bc6156e26fc3fa98033fb0d4d87d710fef25baf9704d47f441e0f5eaf79eee1baa057dbaa10c5da55ba66cc3d7de8518e4b0a4fbbbeca75420ec0fc3ddac664062dea0e7e1d88be4bed4f3cfc6737da2a9ca0826e67ac658fbf7477756c2c1a2e92e50fcf0db3806350fa1126e4a101544a13de898ed5fa5dbcde0a6ce17e96e5786a167f2af9a175e96ad2d9c897aaca4a5dd568c3bfe1473192db11dd231cce616cab893e428a058cd02a1a6e3018a2966bd057f5100d42def50f5b48212a65375e5d49ce9838e066a8d1ef94edcaa0ed8420f7160be15cb8357455ab28086b55409c0f1c63a8772e9a110048903d3949f779e0706ff70e5f91f6ac1174cbe268a7ee4fe793def4512967689ea439485b2fcff126a821211cb1213e7d2de8463d67d8adb111ce9ad60db3667d5f06665e98f414c539f6f4482ecbf11f5897bdbd3af5cc8cee4e0191068b38ba53b317db9516fc12c000b4d5610f34ed4f997ee8370c4419cb94c7e236c25b623fa008223b20aae3b7816526b97e63fc6555ff71a7b114b33a01644bb645da14c4b647e4362abbd9f0509bf56b64bb2770e222a65f899cc14cfea2c588892a00cd87de008e05ca76d08852ed0fa9f2b467ab3fcadcd5b70beba64ccab8d2f35b17b60f143ad6d8834104372592bd7647a8f2689e1f79735ac439210ec56e0d13090979cbc755db84a03586e5000e05833015bea07fcb428933343cdb21a1c8e039c7b1c33c36ebb6619c55e1197b84e7a852c7b5dbfff91894bffaff05d762cb5a694b99261927a8b8572473c0bf1cb97f64e4ddf83eb895bdd0be28ade0a5246cf3085d8e3cb23ff4a281c22e3372b02fe550868c25376f4d9c24a4eef927ea814f359edcf1d9ff2e5a770b5cddf89c99f2942c8536e1fe3a29e79f14af6e421f612ae7aa1acc182a926fa63cac9faa278cbbb008ccf24ef9997c022ca4b508764cc5898406ace913016a027d412d6f13fad6b38c64078c2d3fe98f54711ce5015cf56ea7c73127daa2072e579d9774567a89e9db5c45ce0605113c9bc95054c1ff51a5dc70cdcc8697dfe63168e5d7b6a35eedaf2ae5d91cb1ebc97df41eb1ca68ebe139dd6daa791c493105b8231c24bb75b86413d7e158af450d23b80c365799b9db0eb0477d953cd4edff867ffe058cda36cb7f1146e1dd308ee9fd9a2b1f","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"934c14950d2a7b4c7dfdf5b951d6ec20"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise, the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed = "/images/invisible.svg"
                // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened = "/images/visible.svg"
                // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
