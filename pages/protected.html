<!DOCTYPE html>
<html lang="en" class="staticrypt-html">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/png" href="/images/waving.png" />
        <title>Locked! | Sunny's Website</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #FFC000;
            }

            .staticrypt-page {
                max-width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                /*background: #000000;*/
                border: 2px solid #FFC000;
                color: #FFFFFF;
                width: 60%;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 15px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            @media (min-width: 768px) {
                .staticrypt-form {
                    width: 80%;
                    margin: 0 auto 100px;
                    padding: 45px;
                    font-size: large;
                }
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: /*#f2f2f2*/white;
                width: 100%;
                border: 2px solid #FFC000;
                margin: 0 0 15px;
                box-sizing: border-box;
                color: black;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding-right: 5px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                /*background: #000000;*/
                width: 100%;
                border: #FFC000 solid 1px;
                padding: 15px;
                color: #FFFFFF;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #FFC000;
                filter: brightness(92%);
            }

            .staticrypt-decrypt-button {
                transition: 0.3s ease-in-out;
            }

            .staticrypt-decrypt-button:hover {
                color: black;
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
                /*background-color: black;*/
            }

            .staticrypt-content {
                height: calc(100% - 101px);
                margin-bottom: 0;
                /*background: !*#76B852*!#000000;*/
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            @media (min-width: 768px) {
                .staticrypt-content {
                    height: calc(100% - 70px);
                }
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: small;
                margin-top: 10px;
                margin-bottom: -10px;
            }

            @media (min-width: 768px) {
                .staticrypt-title {
                    font-size: larger;
                    margin-top: 10px;
                    margin-bottom: -10px;
                }
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .staticrypt-hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: calc(100% - 101px);
                display: flex;
                align-items: center;
                justify-content: center;
                /*background-color: black;*/
            }

            @media (min-width: 768px) {
                .staticrypt-spinner-container {
                    height: calc(100% - 70px);
                }
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid #FFC000/*gray*/;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
        <!-- My own things -->
        <link href="/output.css" rel="stylesheet"/>
    </head>

    <body class="staticrypt-body bg-n-8">
        <div>
            <div class="top-0 left-0 w-full border-b border-colour-7 lg:backdrop-blur-sm h-[101px] lg:h-[70px]">
                <div class="flex items-center px-5 lg:px-7.5 xl:px-10 max-lg:py-4">
                    <a class="lg:block w-[60px] xl:ml-2" href="/index.html"><img src="/images/sunnylurking.png" alt="leftlurk"></a>
                    <nav class="relative left-0 right-0 bottom-0 ml-auto lg:mx-auto">
                        <div class="hidden lg:inline-flex relative flex-col items-center justify-center space-x-20 m-auto lg:flex-row">
                            <a href="/index.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Home</a>
                            <a href="/pages/aboutme.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">About Me</a>
                            <a href="/pages/projects.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Projects</a>
                            <a href="/pages/contacts.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Contacts</a>
                            <a href="/pages/blogs/menu.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Blog</a>
                            <a href="/pages/miscellaneous.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Activities</a>
                        </div>
                        <div class="flex lg:hidden text-center">
                            <div class="absolute right-10 hidden w-60 border-colour-7 border-2 rounded-lg overflow-auto" id="navbarHamburger" style="z-index: 10">
                                <ul class="flex flex-col font-medium">
                                    <li>
                                      <a href="/index.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Home</a>
                                    </li>
                                    <li>
                                      <a href="/pages/aboutme.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">About Me</a>
                                    </li>
                                    <li>
                                      <a href="/pages/projects.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Projects</a>
                                    </li>
                                    <li>
                                      <a href="/pages/contacts.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Contacts</a>
                                    </li>
                                    <li>
                                      <a href="/pages/blogs/menu.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Blog</a>
                                    </li>
                                    <li>
                                      <a href="/pages/miscellaneous.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Activities</a>
                                    </li>
                                </ul>
                            </div>
                            <button id="burg" class="button inline-flex items-center justify-center p-2 w-10 h-10 text-sm text-gray-500 rounded-lg focus:outline-none border-2 border-colour-7">
                              <span class="sr-only">Open main menu</span>
                              <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 17 14">
                                  <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 1h15M1 7h15M1 13h15"/>
                              </svg>
                            </button>
                        </div>
                    </nav>
                    <a class="hidden lg:block w-[60px] xl:mr-2" href="/index.html"><img src="/images/sunnylurkinginverted.png" alt="rightlurk"></a>
                </div>
            </div>
        </div>

        <script>
            const burgButtonTemplate = document.getElementById("burg");
            const burgMenuTemplate = document.getElementById("navbarHamburger")

            burgButtonTemplate.addEventListener("click", () => {
                burgMenuTemplate.classList.toggle("hidden");
            })
        </script>
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Locked!</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="../images/invisible.svg"
                            />
<!--                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="-->
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember staticrypt-hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect Password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f1e29fcdfe512d1730a5d56e21827383366c80252be78d64968fe6f4958c6ca72112bc006d7538f0e7e018bacaaa65f6772d0f1715d62f245eb9b37e09f6c8d800b7b05cb4a47f1992a24d75a63f7b3ba29a0a5bf055ac4640e18cb5c95fe16403f5907cea3291089989c08438e7417817006ed4c39d5e9a268e8611e32543f15e9c809ec2daff6e7c0ad902172d9ef63964eb0e05ba8474b192055af787f4c6bcc0522101f60c287f9d2172f76503e708e771d6b8b07a36ee112963bf99d737492e770637cdfabce609944a4b59341d66ee517f108d3e33f5418c73ede401add6243eb6688c0bbd760ab2c2d2c2a16139194b6dc1f87002e122c99c9cc686985a10fd1f884781130d5c02e2cfbab075a5a0adc7b24aca794899f4e87d79d8622f8cd9c86cbf5f945c0cea9bab549544f4d12d2a6260dfa582d146b15909b746cd47be7e0d8a39570641fe1d2e36472630d43de51fd77180a15156456c7ea9733021019d6b095e1230f43284370f57deb1fcfe0bdd9a930b6c90b8e80b74422993564289d7648ef973a6c0ea405f95d7fe235b0d29ad5e162386f7ada768748ed2f1ca6d791082d43ae24bfd99c24dc348ae8cc16c8ef3badb9901a3ff5fa6d117bcbd23691a6f01947cf4d0ffc75c983b0979132c2411eeb2e6ae8a9b5c500184eb6ba52278854a656d6038b4919be8268753357ac98ef7a5cf9380ab9ec7f7c6768130a95e520b2739fc4988c55f972ea1a64bea3d23a655f5690bc0d563202cb8bdbd3791004521918c318b2ad153d57be20d65d77be26b95f6eb21ca64f777a9ad1bfbddf707edef2b07646c05e276ea25eb84aaabbba88c07eb06f9401da80ae68a3fbe3a021eff93265c45400e6aca7f32cc0f0ef6b58f637208df19f30338b982e4b254cc14354c50fde1a682387ce157e363f917e2cddeaaf3eeace954af3517e834230900036e1c77e360cd3b45fe9d66568ddf601c3919963917628cfca91b23be6e38f4fd6398bebe89f58f6bf2943d0a81913b763de47ca9888e9681da144ae9930ed38e8e805822dfd295195966f480d1b5c142677470292890bf5f12b1ec27c8e3a7ff81fec9dce4fb53f7f108413e8f03dda55b0e62335eea3a6765dde4b39e4b8c6d86a2913f6bd8359b2b271e03af6e4dc12edbe471702d9c7cce7870e1cdb2b0995faa2248a90742995a79732ee11fe165db491573aa30193b912413c71375fb0a661f244dacfee82e20434efc163aeb56cf15af74ab13f654e8d9db500a7809e092cdfa76eab4df13234ae94d312066776c925a3b21b61064444fd98661cd3693d49f3913d18944de5b12d1fef4244f9e75736fe809eeeb6186419768bc5273fb98926d24e2e58cdfe1728401dcae44e99aed4bcee61f7a67b2c8f438a2c5475d7d71a4167c9a7f0a78f04c4c9fb902902f1acae3052a5af946569f350ed2c8db86b7e05e7ed9631e9efc5cb4cd7b74a2ba08e1417023578ad3953a7bbdeb36125882ea9fe3dfccd408f17a94c3896ce964f922d28052877a344406d6efb9059b19aa826a98151d61d87f9d034d7a1b8fdbf7cf391df9319764cacfb807adb75f6db40cc4979d8eeff75cb7a81c2899ef257b78738ace3b8ccdf8a47d42526a87cec4f5dc3e35cbb9f795bd1cef22ceb2b2e611f11b1ad7899c9bf48172a322dbce0430447bdc5c51ca5ac171971677277b8155eada5a73a267e0fe54a86b22c8c83d3040b582124963c5db4a9144dc4e64762df01c623ff432d64503f6cf3c51847b52876dfb8cd9232da146e1905ea2c5363fc0ff3ae0153ac0be2dff9f664e869e510cb3d043b5fe80f814eb852cd08e6f4f10607c29b4a993f08179fced20684cae6a49cc70c8d8fa0df48218c8d889d639c6987e0b983d9f63f16a7d53db9a661f4211189ed5129e34694789b55b8dfeeaded151004f1859b0e4728f98c10144cd96389468e56f84330cb156f83fabaa98024f676822200189c03ee538ba22d16165873d1d848aa6b6559c74c3a9bcbb015c34f7b1f85b9a5728af6ce2caf2bfcdc451b6fdcf781361280e027772e80fe0d2b69390ceed3729d2b499e9a4b54fba39a0b321e2ee7fa78e1117597828c6daf89efab9a5641bc7ea1ae22151a40df296b88ab263d72b7d50bd68267c03d6b17bca8d0b85c6b853b52a4afecd09fc24e33de08b1e63a9714c871fd71f2b8b4c4c98a907430e07194991b07aac784065276d30653cda214c68c0152da8d4e02d089ab56f58cd030630c84af303d87b1c5a92c9beb171aedd8089642d182f3bec73c67244c814463bb3c4c35ead5e26b9acf694ec24796226f7726b8705360eb2ad54dd4ee3e4e74d33c67ee227acd3cb8498fb788124f5c9cca42c484835a001d39ba9b67ee44ff26d11915e4cb03520aa9e5ea5165014146020a1f7a1a55e3f70ba02054add4d691618d85176652a6be3c48213a01fe8acecb876b6a8b7793f2e05b6867d98dcdb5fd1dfc6279393d44fa70f3819bd53b78bed505e8532bff94ebb85e5c3b44c30cc2c4904ea9cb50d53d22eaabf2bd5ea457237b5924676ab0ec9a702c5903fd292a554db58fe033446a27ef015bff7c4fc699320da3cd3c800690845608c80dda0f858d0e39bd30e78005cbe28bd307cb32279179198000600617cb7b96b822a70bc643b05033fdb63b8f92a4275aed2e93935c6a8b334716d07cdefa9c2064de40670b700d24d87ef30dc0365b8306b0340b96b9d9c1f6978239bc9ac510ab282416a83ad787fd4ce013ae508fdbb3a909486ad736418f74f0394047693966295693db2b1770256176a2721f2b981a85aaef9aa5f8031ef78fc9370af5824e285d7f52e5fd35e70fdf4c35b77958253d41eb71a1607bca42be7f90bad41e0698fb2652bc9aea35e556a8f30e0d12bc19a811622ac0639e2797af57b0bce9f60a661cc758147dafe7eed8be6f4d2b23f9e44d48e8f91e50c33f69a141bca178af934efc0d9dc9d6eb0cf44c84a6e13d5c45a038f64a22bd969bfbf40feadce873217b25c3f004f840cde8e90245417be731e08706193c974cd53f69b98a58e936c62eccc261af03bc7fd4a76f0333d59b3fc5f411cea4beb9375b69b4972868fbc27434233d6c994a9a78f4817044eec95d49bbddfb4d8bbbbb4ad08bf517abd61f56e94128d949b82cefddc189e662c1fa5b6b97ac5ffc96026e2d6df521fd8a7ee58a0a7c29a215a2b448c52cd151fc9fe9ff3d2cfa45b4f9fc1536ebaba487c96b009ba89c00831945021ed3d5e7f055609260edecd4edcfaf29cd8f2ab99a0afbd48050b45bf142ba90dc69cacc60ed86e8adc8e4d6fe3edb9336e153c346b615d6dee0ed376959cce4f34ad1c2a90ca818307b3b79cf8c487ac4063e86be18e1738c1ffe399ab11ff2ed798a1e747bdb78889db2f27abcc01c5d740a67125b22d2983ddbc52082a9626e34ee5899286c92cbc5d1ab2057827d3ac17463caccd819bd8c30b496a0ee50515bbde48f6b020f4ccd47e7cc9815529ff307f0d76f5626188362e628b57632ac5ff3763a4e2a4a9c374cd2f75ee61d3a59482d7b9946db284f283dd19b3f28e646137c7729f4911ff37891f6f00d223eec5e1c36308838b303df78bb1a113f7a63234ff687c6c804be16e70669610549e5d167e7dbca9c2096facec210ea2c3d4256bc0bfc08b1426cae655a1f7364fa9936026c55474626f46c096aaaec6e8d22cb9a026d55abbea3e1a0b16d33865faae7f8cf5bb03cfddd7130ebdde5fe945e7b49ca2dbad66f010705e7cb763b56e984123000940bb601d19fd4a40e7ab5bf6514914fb6670b1946ecfe5d8e8d8fb913bf04c70b3cb234c4065a569181f84b2590ba037626e240b83bf2e6f5738a013178ab119d1e4b86c9aef4fd65caf48fb7d17afeb494362c03f5fe58128a2c6adcab089a247378c4804d5b86dc8f3717db3823ba937a14feec5fde300f7ccc9b60e3382ab4a5839a0a2a62167382e0bc4320ce50e9e42ad5d304b8c3b5dd69dd5ab752090a7059b373b2d9c14662b21fa9586707f8152fcca35212dce82b71a4de61fe157504d69598ecca2d672b199381665437c2fc917c8ba61415b86c1d5c3d9e0fb48074ad59c00ba4fbc43d57dea397ac247d86cfaed226d9e1e8576190495df8c62b23857e83b187240fcf5dbd5bc5311c5b48e73f8073ed05aa45ea63eb8edae6bae9b10dbb5b3922b8f6a16e103545eec9b856b019e420be004785105d02f5d54d60c9e8713f2ee8d4e5952418cef9a6169a408da6278beed23763148d65de2d49d7105c2b0d243e2db2aebabd784a235eb5c07880e77e9a4aaae22807f03b62d544403b329a8aac9dd33e64ce72fdacdd797881118b3f15641a9589a0271e6d76006403c0567997eac6fe54f81594de78685751596166a096ad06701c053ff64e76155d1d6f52e006c91517be5548c4ae1e157f9ce18e1e4d61b619b836810056e229f8f025203956466910c3afcf26de379a22491d203b38be35c02a63d4ebeaeba627f2c18eeaef72c9a99832e449f5120d7c12b424f11cb6d083d76504b0026c9c0d408ef9bb88abd2b30877a7aba9faea0925053545b247549b7c66b30fbafe8dfda3b8d6ba7366473b975d489e7cba0326637460895d3545ca09ccfb7e9a7fe697076281b8bb9e9e0704b05530e8c86f41aea768c2a7abd0257fc8ef10518b75cd5d59826000a3d225beb6a3ae42a49d7a1c13578a9397dca30b70d6f1de61e1f78a2cabca49460dec7953f89d0ee9c22ba994d11ea2d5e47694d102367451fa375225d76f9e10c792f0732ef1d3441ad129d6ad3d1e90c4c7988c2fe598cc39dd537197e81078a5703fa8e47311c8580ed8f1c2b337695778bda94a98dc32bd58da90d8842fef3e369f19aafb313dc25c7f1075f024fd6369ec2d7fc4c43691fc25d59ba05bc00090f06b63ca543a72e2ef486413cd0de53114fa93ec6e54f2a728d7afee4a8d95548c742641830c1ff0fc82dda6d4db958737b0e54c568d0f9efe19af9be64b9a07d98b4ead885b9dc34277906762d12d413c9dd772f9997de2ad0d4665881b52fae4689d5321bbe6498e4344bbbb2973e6575000cfc9768583ee09936d18351c78ac890a192fc19b92251debaf0c9ab77db4b318eb207b88eb712f05160847da50e105b89248e157c5e05b4523e38688c6722432d004578ed35d1b95817cb69c5b01aa00b3e7704e071173c024687901698898a60dccfa7007165f7d0dfd071a48bc5f2d29b872ab5a776e7cafeb2a4ee2513ad9ce87b0562242ab76f47259a442a1c480d4497f524c5d8eaac30f576b5892666a5606e4764a035f91a73c1e95a21da5f957f691e3f0f2c8dc418666c43299305615797426d50752d10d76300693b82925a102f43d016bd4aca6b3f3db5e8f02f0f5c3849cf648caacd42769e2b4e93d08d607309ba9f5e895b3e03eedfa1fccc477d0ceb7d0c76d8149986f5a9f9159beb3cef114f312441c9a95b253bb727d5623b5d8a80e8ae1b5f650958500ea4dcd6845fb38c5ca07025bd8f72ffe0ccec3b6f35f21b5547f2d1d3080c8af3590178c8169cb7ca6e9fc69fde1342687593f761fb9f0a6ed49479b036b486e651d411c18de25cb5f89c88d8d441c85ed300ba8ea3d22de8ca3adb47558496fc02732a9e66544a3b413458f4295fa3a5d33aa9bfd5dc158d22c84ccd2756d22927735f9e24b415eb68de539ce3b31f145441effedf3697b77cc721732e7e9ee342550d57d417cd3b1117566919896a8e1d739be7e403a47f681d3a1c36c4348c0497be1cd9cbc30caa1703fc3c0d038b64015f0b45036c9af7782e6c0f2f5b399c030d8f8fec50def969b7a264b3cbb72df0d66c024d1b99440ce369a2a4a10fa1d4a96b08b47748351da469d6c004362ce0d81730e32c5848d5c2a01dab502d3046e1a19016a4e508b9b7ccaa7a2f24802ee9783ea5030d2199566bd46e520c005f4c93961e39c5d272effcc023eac6c6440276b236a719b89619c81ad2234a06f1b028cbefeac2dc7a92131eac9b0e1d761a7481c87853d92277410ddbb67ff9103ece92d7ce9be2c30177dad8a89ab954e44ac57fe3d1e4668c893b576410166bf6b134c14e722ae4cab76bfb1e36a97e39816619ecfe2fa4771e7e6bd204a194b3bd6ae6201c429355bf93bd6cda4860994c2a0ccb5b581576060e113952328145e2537323c654c0ac65b524d07844db301f74e06f8ae2633248953b38d41ea9e2d8c314ee17b6bdbe4e02e0d792466e91676585a3a08fb47aa6e482b6d98f7eb8320165c835b81fd19d62aa744ecd2e89992d8e9e6c62a9be7dd0ce82b30405890fc42fa1913b0cf9476600b7f622ad2d0892bb00b8d0bdf905b2b6fa90808e55443eaf56395e1837fff10cf45fb9822abbab1f187670c0644af79ce6583df6464fb87c0502c81601b7393c1944b13118fbb4b60085fdc218103c32798e5a88d700bdeb911da3aa803b1e81172ecbd0327cff7e0ec79823251d3b7b47990b2ce758c6dcf33adf097c0ed0a5bd65eb1489573055f90b6d8cac3a9585aa4980e1b0d0b77d98e4440175e7134e412e15844ccb5409bd82895af8f86001a1c891beb57344b0fa10bd24b9db0d293272c4a7d7c86762eedc9b4a19c5f23e59cbbe3bb99af8173536c9415e7e4b0aa5fd3f73d3e158a334dcea272e0b5aca084ecc194b82399af4ea99d066421048514075dd638dd68ffaadb17b8956deaff7f3a052b8887626d19dc706318515c25b68744a8922531d0e07cf099da47a741d681d1080269aaf9c8a067db5ac35c0f0b3f7536b31ab0a37da7919364b75b30f627dab719e2c552389c85fcc8fdd3d9d1a69d404b9d85c867e4561f6114ccd2edd76cb10c63cb93170deeaf505a04b8f269fea5ddf92af17c5a5d2765d4be21866ee6c795f8e0703328ccf62d63e2d93286afa3bf31d48173bcd3b83156cc094b19fb90b793f029a3b5258ff56c8e2d8aa6b2923aa5a3cdf44b9282afb6e03840eadf8c85f6655a74309be36b1fcfd3e03aa829c4c78cac1e6d7ba379992887799093cb11989d2f31b5b831b7275eee66f849f8b6c6c334d56755d2290fe0cd6f4af55787a08b5aa71322c9dae832bb68b890afeeb2e7ecf7df2a4492c8bff58d2cf81e96423ac62491b215fcd308b832b83723acfed6856d771d70913d0e5055496aeba0289bb03699a17cdd2f311cbb4589336ea5a917cac84a99b140038c30af8455caae4634069c027736b022a96ce805d397eaa51041dcc1ba17e208119c9863e1a12fcb102c32e3865ab6b730a8b0b410600a9cf33f83979c3f8df5ade52559479d2a0b18ad41a118f3f225d74782bd97d4ec4b4f55df5655463bf203566cff378fd8c210075c1f99f4d1cd5f337c933613d08ab80e49ea84ea4f9eae915a440afb6f090a1e58ab3b04d7628721f68fa87a9002a89df110dfc8b98da6c7dfa6801213870aa1c46d96982e73dfac2eb4775a6a839d7e7842ae528ebae39f5b1a0d7ca5f5fea46546db84be932a2b172f35c57d2110844003ee3ba49b0750fabf4573548216a21399a84a02181355096acf130b0d2a95b964605372c9194b81231d1583eaae6510e88972245baa1be393387410880c3637a768558c6f81c2a2195b00d11d2e6415ed13462292ba5ef4cee9a2145c9dac6de48e0a3e9c4ede3fc72c8f62bed4769b3d882fa6b2c9405419e669d906e02444fe719bd03b78b5d77cccdc4df7f23ef43a447f61d4662fb4e41107ddce1c46009ade6453d8aa92aab905eca8fec2cceb936124b6eb008a13d9a457f54bbc8f59679e03d2af321cb7a21e80fc14a61c1cba831ae6b089fece017efa5a448cc6d91eb6ca298f90bfca81fc2c6a4fc7a3498a0c908eef13c7b907c3a6d2bcba32ff54537d7ed363bfdbfd85831fc10359a320c2f4f024d7c7685482064cb4f713922b4d3d870b0d364189cf83f5aaa0a46db2ab40524eab2268eea83fd051ab7395bb079e2b12e64b8e1d855b26e58386953e7fd20fec86baf7319d465bd5ecdde9b9450198eaedf03dcd807bbe124c773cb85861e8f25a38b02bc4cb1463a793a087a02383e15d4a3eb121ade5372adf4a20b252e9b730f7a8bc0c323ccfe9d7daadeb277cc221fa29d2e55fe3ff538ba248b1867fd665dc9b1f058ce62638d1c09fc7e980ea152c54c0e268b7cb130145098b94b3473b8b77292e89202e66eca43f144a08eb7c3b9aced64fa17f397bc4fea60c4f7e8b9e95bb1d3a0bff746187db914cf38e59cf5ed3051c15d4986d26f26a3eb027ddeb357b29c0834fba400ca74b41c1758f46b193b3945f1e9953e39de4ae19cf864d594e71f64d91e7c0b2c8c5db5e7634f16c200ec37068bdf94cb3c8e74a4c013b26ec3a2bd68ce639be323225c87d82b120d225be75f9bae8c5150bdbc3194c13048f953fb8b2b626e080530a302ac8af25c23a973eb7918ca870223ec5b005b4ce4922efb4924d884e3059e062370782bd5a7ef8d39a43fdd7f6063f1cdd6ee975061bb284f0447fcac375475e2f756f052cfae6f57595415808b8277ea4f1bb4733a15af486b59dc6eb76d4707b70bfa0b7452b87694f0541295b9d6bb269881d6c94d716552c9daf2ee683a2e8bc7ba5cbbab287eeb6455b00bdf62970ece7d09f0f3e6651628b4453f77da1b90ac07535df57983ffa12c6d8d16ae005aff3e58169e24ff39aa8841ef4879f0bb780936ecb588ad34bef2a559d737066916a1c9e90cfc9136e789d1550aa437896e502adbe81d97df8cf46925e1e09207487dc35312deb4af308d8f361cc9b3312ce7b90841f103418866a322b7872afe7355969a0f96f0cd9ada4cedf9f196340ec6ab18c2b788f57a16472e686624305c3539bbfe7426372de7d306220b0f53c6c0da8c8cba9b05af62afd025e084644ad7ea91c9a30c8efd98aeb96275e971dac52a36a2486949cb17adbb9756280abbfb187ef0c133f10b7cac42a5c8fc2a8d13b3ce785d38d340851b923c6298c9186c66f3bf0ce4e55a3d9293baa636f844c143ed8ab4f0c38d3d064a6d61d3ba42f8d046dd00aa3465a9c030891ea","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"934c14950d2a7b4c7dfdf5b951d6ec20"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise, the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed = "/images/invisible.svg"
                // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened = "/images/visible.svg"
                // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
