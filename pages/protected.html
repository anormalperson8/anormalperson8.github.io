<!DOCTYPE html>
<html lang="en" class="staticrypt-html">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/png" href="/images/waving.png" />
        <title>Locked! | Sunny's Website</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #FFC000;
            }

            .staticrypt-page {
                max-width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                /*background: #000000;*/
                border: 2px solid #FFC000;
                color: #FFFFFF;
                width: 60%;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 15px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            @media (min-width: 768px) {
                .staticrypt-form {
                    width: 80%;
                    margin: 0 auto 100px;
                    padding: 45px;
                    font-size: large;
                }
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: /*#f2f2f2*/white;
                width: 100%;
                border: 2px solid #FFC000;
                margin: 0 0 15px;
                box-sizing: border-box;
                color: black;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding-right: 5px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                /*background: #000000;*/
                width: 100%;
                border: #FFC000 solid 1px;
                padding: 15px;
                color: #FFFFFF;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #FFC000;
                filter: brightness(92%);
            }

            .staticrypt-decrypt-button {
                transition: 0.3s ease-in-out;
            }

            .staticrypt-decrypt-button:hover {
                color: black;
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
                /*background-color: black;*/
            }

            .staticrypt-content {
                height: calc(100% - 101px);
                margin-bottom: 0;
                /*background: !*#76B852*!#000000;*/
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            @media (min-width: 768px) {
                .staticrypt-content {
                    height: calc(100% - 70px);
                }
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: small;
                margin-top: 10px;
                margin-bottom: -10px;
            }

            @media (min-width: 768px) {
                .staticrypt-title {
                    font-size: larger;
                    margin-top: 10px;
                    margin-bottom: -10px;
                }
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .staticrypt-hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: calc(100% - 101px);
                display: flex;
                align-items: center;
                justify-content: center;
                /*background-color: black;*/
            }

            @media (min-width: 768px) {
                .staticrypt-spinner-container {
                    height: calc(100% - 70px);
                }
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid #FFC000/*gray*/;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
        <!-- My own things -->
        <link href="/output.css" rel="stylesheet"/>
    </head>

    <body class="staticrypt-body bg-n-8">
        <div>
            <div class="top-0 left-0 w-full border-b border-colour-7 lg:backdrop-blur-sm h-[101px] lg:h-[70px]">
                <div class="flex items-center px-5 lg:px-7.5 xl:px-10 max-lg:py-4">
                    <a class="lg:block w-[60px] xl:ml-2" href="/index.html"><img src="/images/sunnylurking.png" alt="leftlurk"></a>
                    <nav class="relative left-0 right-0 bottom-0 ml-auto lg:mx-auto">
                        <div class="hidden lg:inline-flex relative flex-col items-center justify-center space-x-20 m-auto lg:flex-row">
                            <a href="/index.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Home</a>
                            <a href="/pages/aboutme.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">About Me</a>
                            <a href="/pages/projects.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Projects</a>
                            <a href="/pages/contacts.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Contacts</a>
                            <a href="/pages/blogs/menu.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Blog</a>
                            <a href="/pages/activities.html" class="block relative font-code text-lg uppercase transition-colors hover:text-colour-7 text-n-1/50">Activities</a>
                        </div>
                        <div class="flex lg:hidden text-center">
                            <div class="absolute right-10 hidden w-60 border-colour-7 border-2 rounded-lg overflow-auto" id="navbarHamburger" style="z-index: 10">
                                <ul class="flex flex-col font-medium">
                                    <li>
                                      <a href="/index.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Home</a>
                                    </li>
                                    <li>
                                      <a href="/pages/aboutme.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">About Me</a>
                                    </li>
                                    <li>
                                      <a href="/pages/projects.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Projects</a>
                                    </li>
                                    <li>
                                      <a href="/pages/contacts.html" class="font-code uppercase block py-2 px-3 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Contacts</a>
                                    </li>
                                    <li>
                                      <a href="/pages/blogs/menu.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Blog</a>
                                    </li>
                                    <li>
                                      <a href="/pages/activities.html" class="font-code uppercase block py-2 text-n-1 hover:text-n-8 bg-n-8 hover:bg-colour-7">Activities</a>
                                    </li>
                                </ul>
                            </div>
                            <button id="burg" class="button inline-flex items-center justify-center p-2 w-10 h-10 text-sm text-gray-500 rounded-lg focus:outline-none border-2 border-colour-7">
                              <span class="sr-only">Open main menu</span>
                              <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 17 14">
                                  <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 1h15M1 7h15M1 13h15"/>
                              </svg>
                            </button>
                        </div>
                    </nav>
                    <a class="hidden lg:block w-[60px] xl:mr-2" href="/index.html"><img src="/images/sunnylurkinginverted.png" alt="rightlurk"></a>
                </div>
            </div>
        </div>

        <script>
            const burgButton = document.getElementById("burg");
            const burgMenu = document.getElementById("navbarHamburger")

            burgButton.addEventListener("click", () => {
                burgMenu.classList.toggle("hidden");
            })
        </script>
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Locked!</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="../images/invisible.svg"
                            />
<!--                        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="-->
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember staticrypt-hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect Password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"58548bbf27ecc9317f18eed443de0e0f6f60617550fee82c404a309730353ef24ddc94792f50305bc0118809b8c107368473deda485bfb06bd5474a16637c2e93b3b485e32d75cd00354d9da38e2cdf9ba82e96a067356e29e604d42c10ef8e6da94298d0f1bd0ff353c56c49276ec5578dfb75356df4c11a416110201f408808bdcb20c17d2e30a506e13ee2c3d3e0f65e10b94df57c720046239ca133825d0324c3f929725cab4b66c8ec8f9eeea6faa8e2b3ff1e280f25423ac7d6e016fda5c91c43a9c5d4da443f405f3f86cdad048f64e1bee1d28decb4e0a114276da3cb8fd8effde74326e46da0b7fde3244576f21789ad485d2905a8b4bb6349587d51fad533b5fdd4c9d84fa8b23b760b391942ebb72f161b656f82360f6e2a41cf13f235b687ce2ea48db59add45b85ad5e820c4cef02fb64e54dd240a2a48136d6d9a1161e19b29d7c21e7a1ef42a0f0d67d13a43fea1cff7659e0e461ed49696067765f34dcfb3056996b8f0be85bb1af5528304c924a43b31f1a22e9ff1cc4f9d1c1ebf712ce4a4e10e3286455f1436eaef6195905c11c555f768b8292eb9be066ff210a10c3b39a44ce9fbd7491bb655c1e5b43d56cb7842eab01826fd8fe6cb5212a2a341729af9795c58e98b5349032a188707c2db334162cce077098a9f74d43fd4ac96d24b2e16ae9fcdff026c6a46f619832d278ba4bd0314141cfaae40d953a10c707eeaf05190c92c21e0bb418ff1fc39c5826ffd1a18922a410171d21d1bcfd53baae668d42eb68daf33403feeeb966a7f4b4207f39829a7bf0651eb50d7f69157978178c954f87b4c6f1c33a79d28fe888f0bb960282432cc5bd195b73e9932e8877d9406df12133c71c65ba0ada582c808899bf702077f77cde4a4c6f72a30d71f3138e3418ecbd0795208b7a03e0e1e179e02df75df14591ad0887a25eb00345d867f21d58822584f45eff1a3a5beaf92afcb6a71317599d155ec554c5c19f2418c9a3ab7326a914935ce8314f8924af030d0eb3f23665c33c7bd3a3eaca7955967931f5218a9fb11821e4732b655aa6fb2e78b94ef4b193f7dcf09ce235e0e8ffd70dc985ae9c5a320b8554e933a8acf3c6ae576f3fd703173c3f9af5ac4ec1c0fbef939d9d9f0b8fa0eb50a1ea543b20bdf442f6dbab7d8c27b061fdd38f1393e0b3400800bf68217f675efd1bc1ad73e2f711f566425d1d0324aa5c7395e0e027df81e0a88314747ccce40a8b311c2e7d4d9ccfe9815af879f236715f6616ab6cd07373ca1f3f7a07f39e480d7a483b9a275c21c691c12a2fd9a46d9046300de6e3a57f1812524a7870278ef03c3bd461e2a847c5ed00967d6e49036bbae82ce0cc72861a386a3a9b3ec4f5a7c52b8c7ffe631f3e76c872c7c8e53f953f3f0a7c2c719fddb30f006ef874c7de8f8947370d0f4cc8968fc0b9cab9dbcbb913c2495c065afc34b45805ff1b5f468396eb6fdb367e3b22aba5d8b308090e8270705ef7088e700063e04665a2e0c5d88b3a49c08fb30debef9b9e355f7cc3c6629cb0c814aecbe3075733c54b6eb80cca7d026cb226331104dde21f8c5b262cc572df92507221a9876af62695c5c983bc8078d957d75a04649279725c6b4136ccc219f3f616f35ba22049447a5b0e4aeabd24f53d7fd2872784b28384da50f66fd77adcd35c4d7ceede9460d8fa96bcefbff73d843be5d2d81310701f89b04022a4a3db65566a118a111dc5eac06b9b20aabb187faa7478048f931775074a3f4966fbe0354c71773c570a0cfc0e0a445302a24c46c93fa8c01e76f9a5fb14f25a465ff5451793f2ea30af4d917bc1bfbba8c236d39b51904b08c3a50b074fb2700b5c92a451a3e94b35414d349170349824dbe7ec6ed7182f3d5e6da98aa787a1c20c02deb569c0dac566a37e494e95c7534bfc984efeae667ae4f63e40ea898d00b3d8f9919d3249cbc158abee6e39b7a9792620cec5aaf2f97b325d020ce3296a939bc8e8c77ea00d0f1c1b479ab011898948310e55a84bf560d8cad71e3429f091b100ee589aab6996deb18b1cf4aa79312955ad95784ab20d2c2c5212b8ba3b44eea8365cd22725dc322825556b1ee721cab2edf8925b1d38d845428e80fecc20a1113064a1fe6603db9c8400f711b001604aefe3e64a8109cff3134402f3dea0cd76e26a6af292488fabfa77a8f20df257fa946390c94e3259732cb7b337fe39b7e40fd73d4e2f9d8c59be310276876b35a7173f1d804994917bca59746020cf353268810e9fb729156c47d9c382bda3742c05f9c74e6efbd45a3a26c68328af687b79b9fe979f97f3b188216a2a0013100713e40af886fba88fcdcbbe20cb8e0365da1a9a517adef8310dace9102932f3158ec771a68951d21db6944e940de4c31e4d7b7dd9d1277d03ef52da2c4461101b8573b5113ebbd16bbf38f981a34d14c5841a6003eeea858aa05b0a11211c69e66caf3d32821fefbca1f6359d75ea309e8f86f50a793cbc568d06e2fcd585c4d7a7251c69f99493a18996425b0b3c68b3ba23e053c9f16e02bc3da927ea3792ed9bc06a36eef5b07483eb7a05cc4f542281e23bd1339e10293838711577c48fba7121c3284be8edaecb5650af53baee71279b40eb64d59bef5e06271bce6b54d8169cd839435a461a6834d53b5d37db8cb496895498d02d9e8a976077c262320675b4aefbdd4cd53990153cfea7ced68dde1bd5440a904be5d43b86d402326b37467a59989567f819f5fd834bcb90fedd9e382c8036622a790983c3fe531c0c7b8055fd619bfcfb985ae7b6e6f78a10de1a273a7918517e417c241760fc397bdbbfcaf1823b4e1d520a6fab4f2ef8cde5e9658ef89d21b62df19fb4aa67c990f792a372c3270fb5ab4105d77fba85b3b47e7ad6c4df7496939b6680dc822afd56f6781b12ebd12c529ffb635adf108e5730cc1875369fff567e16633689996a97c903be0127b71fd5679c1aff1dddf7914db7014bf37992328114228025613c42d32a20a295b5a837cec4ccfe6157280a2a8fff4514d8079c9cb0e867726cc4ff23c2d821ae5bd5072e5e53be95513a118196ee16ba81545018456bb682a6a0ac1d79c8742344c8145f19781cb4928a206b89110ba522c98a68e427702980d4beaa1e72a6a816b5ce4a986085726f0837dd6278ced712c3ecf5222e0a01b2ec620e09f34762565e93a2236e91d2efbb4d3286fedd544284cf651d3fb7d7a19d05d850feebd3c2e7a782a3dd148010844b3ce377c8efb8f740b9ad539ff3f74ac3796462521560afde75fc55e2f89a8da29c50283cd06d64b7be7d32a411071cd123b800e406a449618c03111e2a76eba375045aff40c6e482e62d13072e39d4c0f9f4d0d1a53410ee0e6e93c90228b69fef07c45f8a2de7e2bf0a3cc569033edf9c7ee85d15357e11c336da0fcede6be64d1a799cc4e53c5f913aee687f23bac2269680f12019ec19e64b2875fd33683f08da4bf79b8e04a65316fbac3f777727005e7afbacf45f6d58d024842f659e395c157ce176be2e8148388447a28b758a63821304617b1e847fcae83f52ac4b5cc34a9da446310c8ccabdae5555a376d586ddcdb2624f87182f79e534597d4c982a004598dbe20f3a288f4d20e24a6330a52d86796545b42593e575037b1fa2c5dac8f4d1a7ace1c097ea5296513ec37159d3adfdd5f899d48215742fbc1c96b2866fb04284cfd81dbcde13520f892e098d6eb0bee8c3ccf5da1321aadc254f816d019b3dc341e23607453fbddb93b65eac243552407bd5aa0389935f77a386a562a2c500583fcbb07e20a590d8db4570390669913255028572546d7c494c9254554d88700133a006d816ecb1f74d20e2711e8f3e73eb88f6b9e840353e85329fb8089f3c54555443f50657776dc8a916cf2e3fa3ed77894daca55f2a31e41f0ad98657cac5b017b3ed4de8d7cafa8912d1c63cd78c5406bae6896dfe912ff1aa4646e287f8a6fb780f6f48be10d00b464c7795fd1c09311f60c4577585f045ed011d5ed1ed0f4b0509ebde847203a57176216ffe4d56a1c9c5c0f12638b3a9e94a3361be7b1ce1070e36271d328a85ae9897c93a3f4c28475dbc37e4de4f695379224b322f351a743efee5d7b5cf2f45a727225fbc30bfe7f5045daaac08c4dd5c18acc0b3b743eeb6b6c0d9e99f77e448d1dcf2f473206b5f6c7179d056b861fe0ccc4b878f50b81128d2392a39f09ab0d14ff4efd51b35fb9238981c6dcf1c7b1afcefae41fa23fb550ea42a6b0a1873133b6dbba0f945c03e1109940e2db4ba9e891836dc5e8134e40c8f4493f8ed91988d8055babb6463f5670fb2ae7b350705419ece9858f18f020cc5c726593ab63b9a7761955ff4db3decd3b70dc05e1c1adff11925b347064d6c42d0b8dce2b9bca23bb5a55121812f80f3124022809b1f9c39922d94699b76273acf811bae8f343bebc4b2671d1ba5b7673b47ffe360ca799315cf48e123d66052c70c2ccbd46c5cb8cd5aea9dbd4b40086e6866fdb46f636eeb8eec0e709db5ccbbe95451c4ee25976fa8b45abed983c225fc5e641500184ec5f2164151b8034c7949be370ac0fccbfe8e2347d0b7c681198017461f4988748519274d28b8a199d39f1cd392b01555c02f8ffc71482fae95e2cfcf01bfb0f703b0e1826a167c703fcf8ddc5bc46e498b671d238baecffa58c76281b834fe0ff4349caffc2fb8f185cd0f357d096712e8c784dd54d2c3a28efa37067755b1ad47026927581eb925a99989da43c8b4bbdd1e140e3ddd89afa03a17fb9c18c59c514f74ea067c6a188c8b5c8cde8cc61dd6432163184a0ba930865270f5b4df6466f53ef0585f0dc437c675cabb4f78781af29766dff22e485d7d26261ccdf929a5c4ee6e4718ecb0c40ac2304a4905b7997cddb9e0725482a9b7c48939a075ce7d5d01b2ac64743418d0d234cc10a886bfc2717bf1a69eaf1ea7690f52981e5837738a27cc2cb5541046aba88fe9fdc04bde7710fafbeb2ef578d02ef3d81f9942312c7da02598cafdbd839718b26a526d1e063e402e392f0f23775af123a0a19b7398d25ed05fb1a400f8bca7cd510853ddda52d91fbe47b7caf85a26a53f50443b1a08b766550737be2330d01fb25fbe2acc89b86b5bf07eef99e3b98a6f32fbaea649b0c495f066fcc29bb2931b7c926c6446c2b19c5e59a2a7b695fc9465965fede8a2804bedbd164d02f9331306ce747c1497ede9527cd374958444f53d72f33035a778bcd91620bec3bf0165e63afc4b8e6842960b340f7d943beedeff2ce58afc45445d2cb81280a6b951b6eaf549e50502803de4ef0c22d97a1e53b9fcb162740eaeb889a1518d00e7d9aff8cb55f89e54989cf85f069dd2a053cfe7e13fca3d2c93274d0e95afdaf9253507d2aedc0a95dc6e52b31c5bc7720c0ed5fcba789eccc305e0123542504b1bd7892ad82d2bd7f344f4a3bcda44f97ba2af686aa90f11d75f6c10cc5ab22661df1e19d00b03762007169c20f2e73b81c8b7e6dd180b82cd840fe6e5917784ae4dca3b3fe62cd76aa53cdc96125fd1e2aa42bae49b2c5e96656571066fac41098ac34b8704d329b9dd1b1543a1e59d31af1b411ce9db1e4cde9b1b4c2b84d366614f0b1e79330088e386ef6aef65c3e954b6033b1d50e7768b40876528447482d51b5c27f14e01c45ddc5a25661e0a4d091f83a031e501c44d279960f09f9841344097774a2700272680c499764a14bcd8c5d7207b5ff9c0aa34350b3c42bac35a490e23f82b94149d0f749cbaf8bf7411d047138c91c6085d911e0f415642af20d46a7dc426c28d1679515cccb33f94ca741fd53c757a68a2e125def30024ba0ae7566c143c2b99edd05b7b88c4c37b4309ef93650c994add083336c47903e395467b60cd6bbc4125e6a566755ac5a23687da41e27dbeede53ec614e968e0c5d260aa1dc5b28c5e4c46b538946676a9ac4ecfc0d99617ec40da065fad87c36dd537de220b7364c53d297e9809010ed2ffa5a97714e75767b21594258e09b861ba880957cb6783a7ae8149140ab016bcce07578cf54fbf0884db99638918727f40ddd8cde10ae447dda61558afec5379fe5cdee8bd5b56becd7e4d27271ab64bd98c5a0ee30743489e8558b7b9373f99a08be046d59b62764c8eb0416bdb83314e9dfb55e9d35ca84c8ee9e3c90f372e844f6deffb3c603c65553820ccbc4bf4003890d2bd5a9a19fa20e76a290af7d25c404a196c8cc438ce0e3065046243b827cd166239b080b6db4040c39b954cfeb58cf439bfa09f8a67ca19efe4f3613953a68469892489a47f8496c820ca8eae4af51846e1989a33857f9275a240f686604fe82ce63de9acfa7eb8c90acbafecef11af5ab00669b97f1ca925206c66e0bf442ea601e3ebd534987a7796c4ae880f51a45bae6ea833fe599ab003f63fef2f321dac5d4d0ae19ed2291f6868e1e1268c49d3394dd983a5385e230cba0b2e8fd541ad7aa22105b5ee29dfec9b046985268c90cb327647942f4dabf88300c0f9269e0c08fad7a95d298010399f9314db58f0ca5b3eb226d1a07f91356e1820fdc9e6ed5c26d9e4dd6302d3c29304994498a11cea82bc1b0511b77ab786761ee75fb31f24ef916a4eeeaa996485d76a63d7fecc910ccf5c0d1c5e58c152e8a0b0f1027d799eca8338d51c632be009cb99680be261f2797f2341b4ad412b62235230a327eca5b9efe7c58cb99fc42ecd2dc7b7ab98805b9e2315cb134e9a3656b5a2a805d11d6542e840ff7fe5c8e07660c4290e583de22d4083c64ee6a01d0bf50142fe2687188b8b7d8dea10885b9f9ce6693e70866d4a2fc234681f833439054723365b51ba09878500e9d143f86dd7485dfad9359b8281ce77fb1dd4d3569e6de68b17f2564fe92df68cc961c4983597e7754879871a5bd204751c112cc5539892ed61ee24a4046c1b5c0da654994c2d18e91c198d67233e504e8261170794713aa6b0585094f11a34b43380763d00ae296295e0d2404147dc0f6bddc579342eb774a953fb0ab085d2c97e10c20b29b134f767d264b0705a0fa77870a2b2ef36d4bd52187d80fe0e77f71b63d84e566765ca3cf99175114245bd7c3c0bbb05ed18c2c4cde5008bd005a756e602c0187241d183098ecab40a1d371e742ff94de2802eb554d7fc06735cba0a66ed8c2a5d4824b791d0a38f2efddc3a62ec8cc83b4fa23b9c0cda9c79f1512d0ec629bce0288aa67dea357caf2a598a68162784794981b800f067edf147fdd5e95888e1ac379fd7f0ba977f1d41fbe85c628e1e5e856a1f20b1ecef0b094a1a40824ee59b25922ac56709848a0d78d4aff3f5d61116f7071096b446ca38a94bb1614c2dde581247135bc6fa7742b5808c9942caa328ce4dec60484df96c0c2d09b507977f40cd9285f4893b2a8e5d0d9bcf43ded82d221c4851204398163adb44ea5608c817e358acfdc1ba5a99add724ba788b483329f0f66daec347a645d2e0729c6cca453fd49731234915ef32ba27c65afd20bcf07226ae10d2f3ed2ed831c06a0d565e7414297cdcc8c135414b691a8fde55a4e0701f3c32256104386c15f71cbc6ec0552b3cb7d87c73c8e0a274b820aff882feab13f645886a97c3fc2a5ad7e584bdc9a24992e988cf247954165a9c92a5567ad640c8fed38cec5a2688cdec21e077ef3351a81589d9def92d595f0195182fafddd908a2356453d75cc43a2e85d9eedf2537218a3e20facc7fa3bf9066a4e436c1c2e6139282b96a3fe6bb5371d1c5938ea0c8af1f45695ccd3edc2d30ce0a09f9aedbe918c03cc7b533b446e310fd11e68cafcb06b14db2a57abaa5b71aa24147dfc7750b7fa453e8c103abd64d5439d25160d40e5a1732717a9e363409715988a9c5cb41b2150b2ec5d6d04003b92754afdfac4e3c09fd54395d0ab5632221c8d2011449eb3a515523b2b1c45103a912d3717cd1be82bb70a63b9ddb7755cd595a7584a1574931bde6d8ccce070d9e90f96cf46f64868a93534299921b4ed688ed8a2b3fd83b5c07ac6dbdf3407744794ae8390e2237ed7fc0c3b2777a86c2c0d7600dcd314d10c9d73683624b41f159bd52a3b499aee50088fe3a12d1d71955a823bfe19c2a3e952350fc3311bb6d6fa9e246746e360493d372a6c31022570ea2dcd3ababe58c93bdfcc06e40f42fb04f9913a50c76150118a2f66560457535165b136a4eaaca896f14e2f40d552d1517027cab5013d7a7fbeebc52efa90a5ebed95181004f5d6f9abdfff5873180f89b3df0423fcb8d4ed1037cc25749667e10b3564b995b246358e5eb7ba82efbb0c3782994c39546cfc0ed4f5b30aec35414dc39f46849dce81a83b428d50f845fb2fde4645153004a8dfffeef3b88f890568cad68ff3401aaa829c66c0c038b9351ef691b000bddc723b412a08a6604bf558948414c16aadb347f5899d72a673930599233ffffb708844e2d40587653e15e5e2772304374cbf89a72de4a8fe40344f63075ce790dbae18ce40f5c9414dea5cb95648466a357b55a658f7c487186350ad99287e7bd896b9fd754c4fc39cbd0147462efe0faf91dca798d25c4ced1be6ccb6e625b96ab9a2c1223d811919999378c3bfe010f52ac74b14d5b5c56aedbeb9b62825d7831df7ac45aad4da9cb66d74ea06fde1d6e38fdd097fe96adbcc749176f72c688adb281e919917859a8b2febaf45895233bfa694df735d441bac2f84664e6989c08b904eece8abc7ba170e9142ec269c6c0d37690c00fb72d20cb958219ed9b1543f016f08c367a8511ef0573fed5fc8ace509b475ebcaa59da49c8f0f133b74c06f983b4fa0f00bad84735c9547a2db8aaba1ca2da0351f6e6940323b71ccd2eff6b9e33c7282a51c1c425ade97483de8ca1a78c99a81bcb6312964d35f69edfdb3daadf19376ff3b8a09dc5a9303d715ada19b22478d6c7d833f0b50e787aafa32ee3154683e59a29e927408c0b1286efe317969086905d12acf6ea46dca0888764e9541d79871056bb138586e098e3a359b1c955a78986adcca9856096ff84cb30cbb1674b28fd436cf92207ae5435ced4747f66225511","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"934c14950d2a7b4c7dfdf5b951d6ec20"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise, the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed = "/images/invisible.svg"
                // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened = "/images/visible.svg"
                // "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
